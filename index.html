<!doctype html>
<html lang="en-GB">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Batch Code Cleaner & Splitter — Jay's Tools</title>
<meta name="description" content="Clean, beautify, split inline CSS/JS and download files or ZIP. Drop files or folders.">
<!--
  NOTES:
  - Uses CDN for js-beautify and JSZip for convenience and robustness.
  - To make this fully offline single-file, replace the two script tags below by pasting
    the minified source of js-beautify and JSZip into <script> blocks (search for "EMBED HERE" comments).
-->
<script src="https://cdn.jsdelivr.net/npm/js-beautify@1.14.7/js/lib/beautify.js"></script>
<script src="https://cdn.jsdelivr.net/npm/js-beautify@1.14.7/js/lib/beautify-css.js"></script>
<script src="https://cdn.jsdelivr.net/npm/js-beautify@1.14.7/js/lib/beautify-html.js"></script>

<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.0/dist/jszip.min.js"></script>

<style>
:root{--bg:#04101a;--panel:#071229;--muted:#9aa6b2;--accent:#7cc6ff;}
*{box-sizing:border-box}
body{font-family:Inter,Segoe UI,system-ui,Roboto,Arial;margin:0;padding:18px;background:linear-gradient(180deg,#031017,#04101a);color:#e6eef6}
.container{max-width:1200px;margin:0 auto;display:grid;grid-template-columns:1fr 420px;gap:14px}
.card{background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;box-shadow:0 6px 20px rgba(0,0,0,0.6)}
h1{margin:0 0 8px 0;font-size:1.05rem}
.drop{border:2px dashed rgba(255,255,255,0.04);padding:18px;border-radius:8px;text-align:center;color:var(--muted);cursor:pointer}
.btn{padding:8px 10px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:var(--accent);cursor:pointer;transition:all 0.2s ease}
.btn:hover{background:rgba(124,198,255,0.1)}
.btn:disabled{opacity:0.5;cursor:not-allowed}
.btn.ghost{color:var(--muted);border-color:rgba(255,255,255,0.03)}
.opts{display:flex;gap:8px;flex-wrap:wrap;align-items:center;color:var(--muted);font-size:0.9rem}
ul.files{list-style:none;padding:0;margin:8px 0 0 0;max-height:56vh;overflow:auto}
li.file{padding:8px;border-radius:6px;background:rgba(255,255,255,0.01);margin-bottom:6px;display:flex;justify-content:space-between;gap:8px;align-items:center}
.small{font-size:0.85rem;color:var(--muted)}
textarea{width:100%;height:48vh;padding:8px;border-radius:6px;border:1px dashed rgba(255,255,255,0.03);background:rgba(255,255,255,0.02);color:inherit;font-family:ui-monospace,Menlo,monospace}
.controls{display:flex;gap:8px;align-items:center;margin-top:8px}
@media (max-width:980px){.container{grid-template-columns:1fr}.card{padding:10px}}
.meta{display:flex;justify-content:space-between;align-items:center;gap:10px}
.progress{height:4px;background:rgba(255,255,255,0.05);border-radius:2px;margin-top:8px;overflow:hidden}
.progress-bar{height:100%;background:var(--accent);transition:width 0.3s ease}
.status{display:none;padding:6px 10px;border-radius:4px;font-size:0.85rem;margin-top:8px}
.status.info{background:rgba(124,198,255,0.1);color:var(--accent);display:block}
.status.error{background:rgba(255,100,100,0.1);color:#ff6b6b;display:block}
.status.success{background:rgba(100,255,100,0.1);color:#6bff6b;display:block}
</style>
</head>
<body>
  <div class="container">
    <div class="card">
      <h1>Batch Code Cleaner & Splitter</h1>
      <div class="small">Drop files or choose a folder. HTML/CSS/JS/JSON/TXT supported. Inline &lt;style&gt; and &lt;script&gt; can be extracted into separate cleaned files.</div>

      <div style="margin-top:10px" class="drop" id="dropzone" role="button" aria-label="Drop files or folders here" tabindex="0">
        <div id="dropText">Drop files or folders here — or <label class="btn" for="fileInput" style="display:inline-block;cursor:pointer">Choose files/folder</label></div>
        <input id="fileInput" type="file" webkitdirectory multiple style="display:none" aria-label="Select files or folder" />
      </div>

      <div class="opts" style="margin-top:10px">
        <label><input id="extractSeparate" type="checkbox" aria-describedby="extractHelp"> Extract inline &lt;style&gt; &lt;script&gt; into separate files</label>
        <label><input id="replaceWithLinks" type="checkbox" checked aria-describedby="replaceHelp"> Replace inline blocks in cleaned HTML with external link/script tags</label>
        <label><input id="minifyOutput" type="checkbox" aria-describedby="minifyHelp"> Minify output</label>
        <label>Indent size: <input id="indentSize" type="number" value="2" min="0" max="8" style="width:64px" aria-label="Indentation size"></label>
      </div>
      
      <div class="small" id="extractHelp" style="margin-top:4px">When enabled, inline CSS and JavaScript in HTML files will be extracted to separate files.</div>
      <div class="small" id="replaceHelp" style="margin-top:4px">When enabled, extracted CSS/JS will be referenced in HTML via link/script tags.</div>
      <div class="small" id="minifyHelp" style="margin-top:4px">When enabled, output will be minified instead of beautified.</div>

      <div style="margin-top:12px" class="meta">
        <div>
          <button id="processBtn" class="btn">Process files</button>
          <button id="clearBtn" class="btn ghost">Clear list</button>
          <button id="zipBtn" class="btn">Download all (ZIP)</button>
        </div>
        <div class="small">Processed: <span id="processedCount">0</span></div>
      </div>
      
      <div class="progress" id="progressContainer" style="display:none">
        <div class="progress-bar" id="progressBar" style="width:0%"></div>
      </div>
      
      <div class="status info" id="statusMessage">Ready to process files</div>

      <h2 style="margin-top:12px;font-size:0.95rem">Files</h2>
      <ul id="fileList" class="files" aria-label="List of files to process"></ul>

      <div style="margin-top:10px" class="small">Integration: <button id="codeSepBtn" class="btn ghost">Open CodeSeparator</button> — or integrate by replacing <code>integrationWithCodeSeparator()</code> below.</div>
    </div>

    <div class="card">
      <h1>Preview & Actions</h1>
      <div class="small">Click a file in the list to preview it. You can download individual files or generate a ZIP.</div>
      <textarea id="previewArea" placeholder="Select a processed file to preview..." aria-label="File preview"></textarea>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="downloadPreview" class="btn">Download preview</button>
        <button id="copyPreview" class="btn ghost">Copy preview</button>
        <button id="replaceInlineBtn" class="btn ghost" title="Replace inline resources by downloaded files (if extracted)">Ensure references</button>
      </div>

      <div style="margin-top:12px" class="small">Log</div>
      <pre id="log" style="background:rgba(255,255,255,0.02);padding:8px;border-radius:6px;height:140px;overflow:auto;color:var(--muted)" aria-label="Processing log"></pre>
    </div>
  </div>

<script>
/* ================== Utilities & Formatters ==================
 - Uses js-beautify (provided by CDN above) when available.
 - Falls back to conservative formatters if not available.
 - Uses JSZip via CDN for ZIP generation; see comments for making offline.
*/

// Fallback CSS/JS/HTML beautifiers (conservative) if js-beautify is not available
function simpleCssBeautify(src, indentSize=2){
  const IND = ' '.repeat(indentSize);
  // naive split rules
  let out='', level=0;
  src.replace(/\r/g,'').split('}').forEach((chunk, idx, arr)=>{
    if (!chunk.trim()) return;
    const parts = chunk.split('{');
    const selector = parts[0].trim();
    const body = (parts[1]||'').trim();
    out += selector + ' {\n';
    body.split(';').map(s=>s.trim()).filter(Boolean).forEach(line=>{
      out += IND + line + ';\n';
    });
    out += '}\n\n';
  });
  return out.trim() + '\n';
}

function simpleJsBeautify(src, indentSize=2){
  // very conservative fallback: add newlines after semicolons and braces
  const IND = ' '.repeat(indentSize);
  let out = src.replace(/\r/g,'').replace(/([{};])/g,'$1\n').split('\n').map(l=>l.trim()).filter(Boolean).map(l=>{
    // maintain indentation for braces
    if (l.endsWith('{')) return l;
    if (l === '}') return l;
    return IND + l;
  }).join('\n') + '\n';
  return out;
}

function simpleHtmlBeautify(src, indent=2){
  // Improved HTML beautifier with better error handling
  try {
    const parser = new DOMParser();
    const doc = parser.parseFromString(src, 'text/html');
    
    function serializeNode(node, depth) {
      const pad = ' '.repeat(depth * indent);
      
      // Handle text nodes
      if (node.nodeType === Node.TEXT_NODE) {
        const text = node.textContent.replace(/\s+/g, ' ').trim();
        return text ? pad + text + '\n' : '';
      }
      
      // Handle comment nodes
      if (node.nodeType === Node.COMMENT_NODE) {
        return pad + '<!--' + node.nodeValue + '-->\n';
      }
      
      // Handle element nodes
      if (node.nodeType === Node.ELEMENT_NODE) {
        const tagName = node.tagName.toLowerCase();
        const attributes = Array.from(node.attributes)
          .map(attr => `${attr.name}="${attr.value}"`)
          .join(' ');
        
        const openingTag = attributes ? 
          `<${tagName} ${attributes}>` : 
          `<${tagName}>`;
        
        // Void elements (self-closing tags)
        const voidElements = new Set([
          'area', 'base', 'br', 'col', 'embed', 'hr', 
          'img', 'input', 'link', 'meta', 'param', 
          'source', 'track', 'wbr'
        ]);
        
        if (voidElements.has(tagName)) {
          return pad + openingTag + '\n';
        }
        
        // Handle elements with only text content
        const childNodes = Array.from(node.childNodes);
        if (childNodes.length === 1 && childNodes[0].nodeType === Node.TEXT_NODE) {
          const text = childNodes[0].textContent.trim();
          return pad + openingTag + text + `</${tagName}>\n`;
        }
        
        // Handle elements with nested content
        let result = pad + openingTag + '\n';
        childNodes.forEach(child => {
          result += serializeNode(child, depth + 1);
        });
        result += pad + `</${tagName}>\n`;
        return result;
      }
      
      return '';
    }
    
    // Start serialization from body content or document element
    const body = doc.body || doc.documentElement;
    return serializeNode(body, 0).trim();
  } catch (error) {
    console.error('HTML beautification failed:', error);
    // Return original source if beautification fails
    return src;
  }
}

// Wrapper functions that prefer js-beautify if available
function beautifyCSS(src, indentSize){
  if (window.css_beautify) return css_beautify(src, {indent_size: indentSize});
  return simpleCssBeautify(src, indentSize);
}

function beautifyJS(src, indentSize){
  if (window.js_beautify) return js_beautify(src, {indent_size: indentSize});
  return simpleJsBeautify(src, indentSize);
}

function beautifyHTML(src, indentSize){
  if (window.html_beautify) return html_beautify(src, {indent_size: indentSize});
  return simpleHtmlBeautify(src, indentSize);
}

/* ================== File handling & UI ================== */

const dropzone = document.getElementById('dropzone');
const fileInput = document.getElementById('fileInput');
const fileListEl = document.getElementById('fileList');
const processBtn = document.getElementById('processBtn');
const clearBtn = document.getElementById('clearBtn');
const zipBtn = document.getElementById('zipBtn');
const previewArea = document.getElementById('previewArea');
const logEl = document.getElementById('log');
const processedCountEl = document.getElementById('processedCount');
const codeSepBtn = document.getElementById('codeSepBtn');
const replaceInlineBtn = document.getElementById('replaceInlineBtn');
const progressContainer = document.getElementById('progressContainer');
const progressBar = document.getElementById('progressBar');
const statusMessage = document.getElementById('statusMessage');

let filesToProcess = []; // {name, file}
let processed = {}; // name -> {content, type}

function log(msg){ 
  const ts = new Date().toLocaleTimeString('en-GB'); 
  logEl.textContent += `[${ts}] ${msg}\n`; 
  logEl.scrollTop = logEl.scrollHeight; 
}

function showStatus(message, type = 'info') {
  statusMessage.textContent = message;
  statusMessage.className = 'status ' + type;
}

function reset(){
  filesToProcess = []; 
  processed = {}; 
  fileListEl.innerHTML = ''; 
  previewArea.value = ''; 
  logEl.textContent = ''; 
  processedCountEl.textContent = '0';
  progressContainer.style.display = 'none';
  showStatus('Ready to process files', 'info');
}

function updateProgress(percent) {
  progressBar.style.width = percent + '%';
}

// Enhanced dropzone event handlers
dropzone.addEventListener('dragover', e=>{ 
  e.preventDefault(); 
  dropzone.style.borderColor = 'rgba(124,198,255,0.3)';
});

dropzone.addEventListener('dragleave', e=>{ 
  if (!dropzone.contains(e.relatedTarget)) {
    dropzone.style.borderColor = 'rgba(255,255,255,0.04)';
  }
});

dropzone.addEventListener('drop', async e=>{
  e.preventDefault();
  dropzone.style.borderColor = 'rgba(255,255,255,0.04)';
  const items = e.dataTransfer.items || e.dataTransfer.files;
  
  if (items.length === 0) {
    showStatus('No files were dropped', 'error');
    return;
  }
  
  // Handle folder drops (webkitGetAsEntry API)
  if (items && items[0].webkitGetAsEntry) {
    showStatus('Processing folder structure...', 'info');
    const entries = [];
    for (let i = 0; i < items.length; i++) {
      entries.push(items[i].webkitGetAsEntry());
    }
    await processEntries(entries);
  } else {
    // Fallback for files only
    handleFileList(e.dataTransfer.files);
  }
});

// Add keyboard accessibility for dropzone
dropzone.addEventListener('keydown', e=>{
  if (e.key === 'Enter' || e.key === ' ') {
    e.preventDefault();
    fileInput.click();
  }
});

fileInput.addEventListener('change', e=> {
  if (e.target.files.length > 0) {
    handleFileList(e.target.files);
  }
});

// Process directory entries recursively
async function processEntries(entries, path = '') {
  let fileCount = 0;
  
  for (const entry of entries) {
    if (entry.isFile) {
      const file = await new Promise(resolve => entry.file(resolve));
      const fullPath = path ? `${path}/${file.name}` : file.name;
      
      // Validate file type
      if (isSupportedFileType(file.name)) {
        filesToProcess.push({name: fullPath, file});
        fileCount++;
      } else {
        log(`Skipped unsupported file: ${fullPath}`);
      }
    } else if (entry.isDirectory) {
      const dirReader = entry.createReader();
      const newEntries = await new Promise(resolve => {
        dirReader.readEntries(resolve);
      });
      const newPath = path ? `${path}/${entry.name}` : entry.name;
      await processEntries(newEntries, newPath);
    }
  }
  
  if (fileCount > 0) {
    renderFileList();
    showStatus(`Added ${fileCount} file(s) from folder`, 'success');
  }
}

function isSupportedFileType(filename) {
  const ext = (filename.split('.').pop() || '').toLowerCase();
  const supported = ['html', 'htm', 'css', 'js', 'mjs', 'cjs', 'json', 'txt', 'md', 'xml', 'svg'];
  return supported.includes(ext);
}

function handleFileList(fileList){
  let addedCount = 0;
  
  for (let i = 0; i < fileList.length; i++){
    const f = fileList[i];
    const name = f.webkitRelativePath || f.name;
    
    // Validate file type
    if (isSupportedFileType(name)) {
      filesToProcess.push({name, file: f});
      addedCount++;
    } else {
      log(`Skipped unsupported file: ${name}`);
    }
  }
  
  if (addedCount > 0) {
    renderFileList();
    showStatus(`Added ${addedCount} file(s)`, 'success');
    log(`Added ${addedCount} file(s).`);
  } else {
    showStatus('No supported files were added', 'error');
  }
}

function renderFileList(){
  fileListEl.innerHTML = '';
  
  if (filesToProcess.length === 0) {
    fileListEl.innerHTML = '<li class="small" style="text-align:center;padding:20px;color:var(--muted)">No files added yet</li>';
    return;
  }
  
  filesToProcess.forEach((f, idx)=>{
    const li = document.createElement('li'); 
    li.className='file';
    li.innerHTML = `<div style="min-width:0"><strong style="display:block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${f.name}</strong><div class="small">${Math.round(f.file.size/1024)} KB</div></div>
      <div style="display:flex;gap:8px;align-items:center">
        <button class="btn ghost" data-idx="${idx}" title="Remove">Remove</button>
      </div>`;
    fileListEl.appendChild(li);
  });
  
  fileListEl.querySelectorAll('button[data-idx]').forEach(b=>{
    b.addEventListener('click', e=>{
      const idx = parseInt(e.currentTarget.getAttribute('data-idx'),10);
      const removedFile = filesToProcess[idx];
      filesToProcess.splice(idx,1); 
      renderFileList();
      log(`Removed file: ${removedFile.name}`);
      showStatus(`Removed: ${removedFile.name}`, 'info');
    });
  });
}

clearBtn.addEventListener('click', ()=> {
  if (filesToProcess.length > 0 || Object.keys(processed).length > 0) {
    if (confirm('Clear all files and processing results?')) {
      reset();
      log('Cleared all files and results.');
    }
  } else {
    reset();
  }
});

processBtn.addEventListener('click', async ()=>{
  if (!filesToProcess.length){ 
    showStatus('No files to process.', 'error');
    log('No files to process.'); 
    return; 
  }
  
  log('Processing files...');
  showStatus('Processing files...', 'info');
  processBtn.disabled = true;
  progressContainer.style.display = 'block';
  
  processed = {};
  const opts = {
    extractSeparate: document.getElementById('extractSeparate').checked,
    replaceWithLinks: document.getElementById('replaceWithLinks').checked,
    minify: document.getElementById('minifyOutput').checked,
    indent: parseInt(document.getElementById('indentSize').value,10) || 2
  };
  
  let processedCount = 0;
  let errorCount = 0;
  
  for (let i = 0; i < filesToProcess.length; i++){
    const item = filesToProcess[i];
    
    // Update progress
    updateProgress((i / filesToProcess.length) * 100);
    
    try {
      const text = await item.file.text();
      const ext = (item.name.split('.').pop()||'').toLowerCase();
      
      if (['html','htm'].includes(ext)){
        // process HTML: beautify and optionally extract inline blocks
        const docParser = new DOMParser();
        const doc = docParser.parseFromString(text,'text/html');

        // extract inline styles/scripts if requested
        const extractedFiles = [];
        if (opts.extractSeparate){
          // styles
          let styleCount = 0;
          doc.querySelectorAll('style').forEach(s=>{
            styleCount++;
            const raw = s.textContent || '';
            const cleaned = opts.minify ? raw.replace(/\s+/g,' ') : beautifyCSS(raw, opts.indent);
            const base = item.name.replace(/\.[^.]+$/,'');
            const styleName = `${base}.style${styleCount}.css`;
            processed[styleName] = {content: cleaned, type:'text/css'};
            extractedFiles.push({type:'css', name: styleName});
            // replace with link if requested
            if (opts.replaceWithLinks){
              const link = doc.createElement('link');
              link.setAttribute('rel','stylesheet');
              link.setAttribute('href', styleName);
              s.parentNode.replaceChild(link, s);
            } else {
              s.remove(); // Remove the style tag if not replacing with links
            }
          });
          // scripts
          let scriptCount = 0;
          doc.querySelectorAll('script').forEach(s=>{
            if (s.src) return; // skip external scripts
            scriptCount++;
            const raw = s.textContent || '';
            const cleaned = opts.minify ? raw.replace(/\s+/g,' ') : beautifyJS(raw, opts.indent);
            const base = item.name.replace(/\.[^.]+$/,'');
            const scriptName = `${base}.script${scriptCount}.js`;
            processed[scriptName] = {content: cleaned, type:'application/javascript'};
            extractedFiles.push({type:'js', name: scriptName});
            if (opts.replaceWithLinks){
              const newScript = doc.createElement('script');
              newScript.setAttribute('src', scriptName);
              s.parentNode.replaceChild(newScript, s);
            } else {
              s.remove(); // Remove the script tag if not replacing with links
            }
          });
        } else {
          // even if not extracting, still beautify inline blocks for nicer HTML output
          doc.querySelectorAll('style').forEach(s=>{
            s.textContent = opts.minify ? s.textContent.replace(/\s+/g,' ') : beautifyCSS(s.textContent || '', opts.indent);
          });
          doc.querySelectorAll('script').forEach(s=>{
            if (!s.src) s.textContent = opts.minify ? s.textContent.replace(/\s+/g,' ') : beautifyJS(s.textContent || '', opts.indent);
          });
        }

        // serialise HTML
        const outer = new XMLSerializer().serializeToString(doc);
        // beautify outer HTML (prefer html_beautify)
        const cleanedHtml = opts.minify ? outer.replace(/\s+/g,' ').replace(/>\s+</g,'><') : beautifyHTML(outer, opts.indent);
        const outName = item.name.replace(/\\/g,'/');
        processed[outName] = {content: cleanedHtml, type:'text/html'};
        log(`Processed HTML: ${item.name}${opts.extractSeparate ? ' (extracted '+(extractedFiles.length)+' inline resources)' : ''}`);
        processedCount++;
      } else if (ext === 'css'){
        const cleaned = opts.minify ? text.replace(/\s+/g,' ') : beautifyCSS(text, opts.indent);
        processed[item.name] = {content: cleaned, type:'text/css'};
        log(`Processed CSS: ${item.name}`);
        processedCount++;
      } else if (ext === 'js' || ext === 'mjs' || ext === 'cjs'){
        const cleaned = opts.minify ? text.replace(/\s+/g,' ') : beautifyJS(text, opts.indent);
        processed[item.name] = {content: cleaned, type:'application/javascript'};
        log(`Processed JS: ${item.name}`);
        processedCount++;
      } else if (ext === 'json'){
        try {
          const obj = JSON.parse(text);
          const pretty = JSON.stringify(obj, null, opts.indent);
          processed[item.name] = {content: pretty + '\n', type:'application/json'};
          log(`Processed JSON: ${item.name}`);
          processedCount++;
        } catch(e){ 
          processed[item.name] = {content: text, type:'application/json'}; 
          log(`JSON parse failed for ${item.name} — left unchanged`);
          processedCount++;
        }
      } else if (['txt', 'md', 'xml', 'svg'].includes(ext)) {
        // Handle other text-based formats
        processed[item.name] = {content: text, type:'text/plain'}; 
        log(`Processed text file: ${item.name}`);
        processedCount++;
      } else {
        processed[item.name] = {content: text, type:'application/octet-stream'}; 
        log(`Copied as-is (binary): ${item.name}`);
        processedCount++;
      }
    } catch(e){
      log(`Error processing ${item.name}: ${e.message}`);
      errorCount++;
    }
  }
  
  // Final progress update
  updateProgress(100);
  
  updateProcessedList();
  
  // Re-enable button
  processBtn.disabled = false;
  progressContainer.style.display = 'none';
  
  if (errorCount === 0) {
    showStatus(`Processing complete. Successfully processed ${processedCount} files.`, 'success');
    log(`Processing complete. Success: ${processedCount}, Errors: ${errorCount}`);
  } else {
    showStatus(`Processing complete with ${errorCount} error(s). Check log for details.`, 'error');
    log(`Processing complete. Success: ${processedCount}, Errors: ${errorCount}`);
  }
});

function updateProcessedList(){
  fileListEl.innerHTML = '';
  const names = Object.keys(processed).sort();
  if (!names.length){ 
    fileListEl.innerHTML = '<li class="small" style="text-align:center;padding:20px;color:var(--muted)">No processed files yet</li>'; 
    processedCountEl.textContent='0'; 
    return; 
  }
  
  names.forEach(name=>{
    const item = processed[name];
    const li = document.createElement('li'); 
    li.className = 'file';
    li.innerHTML = `<div style="min-width:0">
        <strong style="display:block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${name}</strong>
        <div class="small">${item.type} • ${new Blob([item.content]).size} bytes</div>
      </div>
      <div style="display:flex;gap:6px;align-items:center">
        <button class="btn ghost" data-name="${name}" data-action="preview">Preview</button>
        <button class="btn" data-name="${name}" data-action="download">Download</button>
      </div>`;
    fileListEl.appendChild(li);
  });
  
  fileListEl.querySelectorAll('button[data-action]').forEach(btn=>{
    btn.addEventListener('click', e=>{
      const action = e.currentTarget.getAttribute('data-action');
      const name = e.currentTarget.getAttribute('data-name');
      if (action === 'preview'){ 
        previewArea.value = processed[name].content; 
        previewArea.dataset.name = name; 
        log(`Previewing ${name}`); 
      }
      if (action === 'download'){ 
        downloadString(processed[name].content, name); 
        log(`Downloaded ${name}`); 
      }
    });
  });
  
  processedCountEl.textContent = names.length;
}

// Download helper
function downloadString(text, filename){
  const blob = new Blob([text], {type:'application/octet-stream'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(a.href),1500);
}

document.getElementById('downloadPreview').addEventListener('click', ()=>{
  const name = previewArea.dataset.name || 'preview.txt';
  if (previewArea.value) {
    downloadString(previewArea.value, name);
    log(`Downloaded preview as ${name}`);
  } else {
    showStatus('No preview content to download.', 'error');
    log('No preview content to download.');
  }
});

document.getElementById('copyPreview').addEventListener('click', async ()=>{
  if (previewArea.value) {
    try { 
      await navigator.clipboard.writeText(previewArea.value); 
      showStatus('Preview copied to clipboard.', 'success');
      log('Preview copied to clipboard.'); 
    } catch(e){ 
      showStatus('Clipboard failed: ' + e.message, 'error');
      log('Clipboard failed: ' + e.message); 
    }
  } else {
    showStatus('No preview content to copy.', 'error');
    log('No preview content to copy.');
  }
});

// ZIP generation using JSZip (CDN)
zipBtn.addEventListener('click', async ()=>{
  const names = Object.keys(processed);
  if (!names.length){ 
    showStatus('Nothing to zip.', 'error');
    log('Nothing to zip.'); 
    return; 
  }
  
  if (typeof JSZip === 'undefined'){ 
    showStatus('JSZip not available. ZIP disabled.', 'error');
    log('JSZip not available. ZIP disabled.'); 
    alert('ZIP requires JSZip (CDN). Download individual files instead or embed JSZip for offline.'); 
    return; 
  }
  
  log('Generating ZIP...');
  showStatus('Generating ZIP archive...', 'info');
  
  try {
    const zip = new JSZip();
    names.forEach(n => zip.file(n, processed[n].content));
    const blob = await zip.generateAsync({type:'blob'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'cleaned-files.zip';
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(a.href),1500);
    showStatus('ZIP download started.', 'success');
    log('ZIP download started.');
  } catch (e) {
    showStatus('Error generating ZIP: ' + e.message, 'error');
    log('Error generating ZIP: ' + e.message);
  }
});

// Replace references if inline blocks extracted and links inserted - basic fix for relative paths
replaceInlineBtn.addEventListener('click', ()=>{
  if (!previewArea.value) { 
    showStatus('No preview to adjust.', 'error');
    log('No preview to adjust.'); 
    return; 
  }
  
  const currentName = previewArea.dataset.name;
  if (!currentName || !processed[currentName]) {
    showStatus('No processed file selected for reference adjustment.', 'error');
    log('No processed file selected for reference adjustment.');
    return;
  }
  
  // Simple reference adjustment: ensure extracted files exist in processed list
  const content = previewArea.value;
  const extractedRefs = content.match(/(href|src)="([^"]+\.(css|js))"/g) || [];
  
  if (extractedRefs.length > 0) {
    let adjustedContent = content;
    let fixedCount = 0;
    
    extractedRefs.forEach(ref => {
      const match = ref.match(/(href|src)="([^"]+)"/);
      if (match) {
        const filename = match[2];
        if (!processed[filename]) {
          // File reference exists in HTML but not in processed files
          log(`Warning: Reference to ${filename} found but file not in processed list`);
        } else {
          fixedCount++;
        }
      }
    });
    
    if (fixedCount > 0) {
      showStatus(`Verified ${fixedCount} file reference(s) in ${currentName}`, 'success');
      log(`Verified ${fixedCount} file reference(s) in ${currentName}`);
    } else {
      showStatus(`No file references need adjustment in ${currentName}`, 'info');
      log(`No file references need adjustment in ${currentName}`);
    }
  } else {
    showStatus('No external file references found in current preview.', 'info');
    log('No external file references found in current preview.');
  }
});

// Simple integration example: open your CodeSeparator in a new tab
codeSepBtn.addEventListener('click', ()=>{
  integrationWithCodeSeparator();
});

function integrationWithCodeSeparator(){
  // Check if we have processed HTML files that could benefit from code separation
  const htmlFiles = Object.keys(processed).filter(name => 
    name.endsWith('.html') || name.endsWith('.htm')
  );
  
  if (htmlFiles.length > 0) {
    showStatus(`Opening CodeSeparator with ${htmlFiles.length} HTML file(s) ready for further processing`, 'info');
    log(`Opening CodeSeparator with ${htmlFiles.length} HTML file(s) ready for further processing`);
  } else {
    showStatus('No processed HTML files available for CodeSeparator integration', 'info');
    log('No processed HTML files available for CodeSeparator integration');
  }
  
  // Default behaviour: open the CodeSeparator repo/page in a new tab for manual step.
  const url = 'https://jaysecotools.github.io/WebCodeSeparator/';
  window.open(url, '_blank');
}

/* ================== Initialize ================== */
document.addEventListener('DOMContentLoaded', () => {
  log('Batch Code Cleaner & Splitter ready. Drop files or folders to begin.');
  showStatus('Ready to process files', 'info');
});

/* ================== End ================== */
</script>

<!--
  If you want this file to be 100% offline single-file:
  - Replace the js-beautify CDN script tags by pasting the minified js-beautify bundles inside <script> tags.
    You can find them by downloading js-beautify and copying the minified files:
      - js/lib/beautify.js
      - js/lib/beautify-css.js
      - js/lib/beautify-html.js
  - Replace the JSZip CDN script by pasting the minified JSZip source (dist/jszip.min.js) in a <script> tag.
  Doing so will produce one larger HTML file but it will work without network access.
-->
</body>
</html>

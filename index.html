<!doctype html>
<html lang="en-GB">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Batch Code Cleaner & Splitter — Jay's Tools</title>
<meta name="description" content="Clean, beautify, split inline CSS/JS and download files or ZIP. Drop files or folders.">
<script src="https://cdn.jsdelivr.net/npm/js-beautify@1.14.7/js/lib/beautify.js"></script>
<script src="https://cdn.jsdelivr.net/npm/js-beautify@1.14.7/js/lib/beautify-css.js"></script>
<script src="https://cdn.jsdelivr.net/npm/js-beautify@1.14.7/js/lib/beautify-html.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.0/dist/jszip.min.js"></script>

<style>
:root{--bg:#04101a;--panel:#071229;--muted:#9aa6b2;--accent:#7cc6ff;}
*{box-sizing:border-box}
body{font-family:Inter,Segoe UI,system-ui,Roboto,Arial;margin:0;padding:18px;background:linear-gradient(180deg,#031017,#04101a);color:#e6eef6}
.container{max-width:1200px;margin:0 auto;display:grid;grid-template-columns:1fr 420px;gap:14px}
.card{background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;box-shadow:0 6px 20px rgba(0,0,0,0.6)}
h1{margin:0 0 8px 0;font-size:1.05rem}
.drop{border:2px dashed rgba(255,255,255,0.04);padding:18px;border-radius:8px;text-align:center;color:var(--muted);cursor:pointer;transition:all 0.3s ease}
.drop.active{border-color:var(--accent);background:rgba(124,198,255,0.05)}
.btn{padding:8px 10px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:var(--accent);cursor:pointer;transition:all 0.2s ease}
.btn:hover{background:rgba(124,198,255,0.1)}
.btn:disabled{opacity:0.5;cursor:not-allowed}
.btn.ghost{color:var(--muted);border-color:rgba(255,255,255,0.03)}
.opts{display:flex;gap:8px;flex-wrap:wrap;align-items:center;color:var(--muted);font-size:0.9rem}
ul.files{list-style:none;padding:0;margin:8px 0 0 0;max-height:56vh;overflow:auto}
li.file{padding:8px;border-radius:6px;background:rgba(255,255,255,0.01);margin-bottom:6px;display:flex;justify-content:space-between;gap:8px;align-items:center}
.small{font-size:0.85rem;color:var(--muted)}
textarea{width:100%;height:48vh;padding:8px;border-radius:6px;border:1px dashed rgba(255,255,255,0.03);background:rgba(255,255,255,0.02);color:inherit;font-family:ui-monospace,Menlo,monospace}
.controls{display:flex;gap:8px;align-items:center;margin-top:8px}
@media (max-width:980px){.container{grid-template-columns:1fr}.card{padding:10px}}
.meta{display:flex;justify-content:space-between;align-items:center;gap:10px}
.progress{height:4px;background:rgba(255,255,255,0.05);border-radius:2px;margin-top:8px;overflow:hidden}
.progress-bar{height:100%;background:var(--accent);transition:width 0.3s ease}
.status{display:none;padding:6px 10px;border-radius:4px;font-size:0.85rem;margin-top:8px}
.status.info{background:rgba(124,198,255,0.1);color:var(--accent);display:block}
.status.error{background:rgba(255,100,100,0.1);color:#ff6b6b;display:block}
.status.success{background:rgba(100,255,100,0.1);color:#6bff6b;display:block}
.file-input-label{display:inline-block;cursor:pointer}
.file-type{font-size:0.75rem;padding:2px 6px;background:rgba(255,255,255,0.05);border-radius:4px;margin-left:8px}
</style>
</head>
<body>
  <div class="container">
    <div class="card">
      <h1>Batch Code Cleaner & Splitter</h1>
      <div class="small">Drop files or choose a folder. HTML/CSS/JS/JSON/TXT supported. Inline &lt;style&gt; and &lt;script&gt; can be extracted into separate cleaned files.</div>

      <div style="margin-top:10px" class="drop" id="dropzone">
        <div id="dropText">Drop files or folders here — or 
          <label class="btn file-input-label">
            Choose files
            <input id="fileInput" type="file" multiple style="display:none" />
          </label>
        </div>
      </div>

      <div class="opts" style="margin-top:10px">
        <label><input id="extractSeparate" type="checkbox"> Extract inline &lt;style&gt; &lt;script&gt; into separate files</label>
        <label><input id="replaceWithLinks" type="checkbox" checked> Replace inline blocks in cleaned HTML with external link/script tags</label>
        <label><input id="minifyOutput" type="checkbox"> Minify output</label>
        <label>Indent size: <input id="indentSize" type="number" value="2" min="0" max="8" style="width:64px"></label>
      </div>

      <div style="margin-top:12px" class="meta">
        <div>
          <button id="processBtn" class="btn">Process files</button>
          <button id="clearBtn" class="btn ghost">Clear list</button>
          <button id="zipBtn" class="btn">Download all (ZIP)</button>
        </div>
        <div class="small">Files: <span id="fileCount">0</span> | Processed: <span id="processedCount">0</span></div>
      </div>
      
      <div class="progress" id="progressContainer" style="display:none">
        <div class="progress-bar" id="progressBar" style="width:0%"></div>
      </div>
      
      <div class="status info" id="statusMessage">Ready to add files</div>

      <h2 style="margin-top:12px;font-size:0.95rem">Files to Process</h2>
      <ul id="fileList" class="files"></ul>
    </div>

    <div class="card">
      <h1>Preview & Actions</h1>
      <div class="small">Click a processed file to preview it. You can download individual files or generate a ZIP.</div>
      <textarea id="previewArea" placeholder="Select a processed file to preview..."></textarea>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="downloadPreview" class="btn">Download preview</button>
        <button id="copyPreview" class="btn ghost">Copy preview</button>
      </div>

      <div style="margin-top:12px" class="small">Log</div>
      <pre id="log" style="background:rgba(255,255,255,0.02);padding:8px;border-radius:6px;height:140px;overflow:auto;color:var(--muted)"></pre>
    </div>
  </div>

<script>
// Simple and reliable file handling
const dropzone = document.getElementById('dropzone');
const fileInput = document.getElementById('fileInput');
const fileListEl = document.getElementById('fileList');
const processBtn = document.getElementById('processBtn');
const clearBtn = document.getElementById('clearBtn');
const zipBtn = document.getElementById('zipBtn');
const previewArea = document.getElementById('previewArea');
const logEl = document.getElementById('log');
const fileCountEl = document.getElementById('fileCount');
const processedCountEl = document.getElementById('processedCount');
const progressContainer = document.getElementById('progressContainer');
const progressBar = document.getElementById('progressBar');
const statusMessage = document.getElementById('statusMessage');

let filesToProcess = []; // {name, file}
let processed = {}; // name -> {content, type}

function log(msg) { 
  const ts = new Date().toLocaleTimeString('en-GB'); 
  logEl.textContent += `[${ts}] ${msg}\n`; 
  logEl.scrollTop = logEl.scrollHeight; 
}

function showStatus(message, type = 'info') {
  statusMessage.textContent = message;
  statusMessage.className = 'status ' + type;
}

function updateFileCount() {
  fileCountEl.textContent = filesToProcess.length;
}

function reset() {
  filesToProcess = []; 
  processed = {}; 
  fileListEl.innerHTML = ''; 
  previewArea.value = ''; 
  logEl.textContent = ''; 
  fileCountEl.textContent = '0';
  processedCountEl.textContent = '0';
  progressContainer.style.display = 'none';
  showStatus('Ready to add files', 'info');
}

function updateProgress(percent) {
  progressBar.style.width = percent + '%';
}

// SIMPLE DRAG AND DROP - This will work reliably
dropzone.addEventListener('dragover', (e) => {
  e.preventDefault();
  dropzone.classList.add('active');
});

dropzone.addEventListener('dragleave', (e) => {
  e.preventDefault();
  // Only remove active class if we're actually leaving the dropzone
  if (!dropzone.contains(e.relatedTarget)) {
    dropzone.classList.remove('active');
  }
});

dropzone.addEventListener('drop', (e) => {
  e.preventDefault();
  dropzone.classList.remove('active');
  
  const files = e.dataTransfer.files;
  if (files && files.length > 0) {
    handleFileList(files);
  } else {
    showStatus('No files were dropped', 'error');
  }
});

// File input change handler
fileInput.addEventListener('change', (e) => {
  if (e.target.files.length > 0) {
    handleFileList(e.target.files);
    // Reset input to allow selecting same files again
    fileInput.value = '';
  }
});

// Handle file list - SIMPLE AND RELIABLE
function handleFileList(fileList) {
  let addedCount = 0;
  let skippedCount = 0;
  
  for (let i = 0; i < fileList.length; i++) {
    const file = fileList[i];
    
    // Check if file is already in the list
    const isDuplicate = filesToProcess.some(f => 
      f.name === file.name && f.size === file.size
    );
    
    if (!isDuplicate) {
      filesToProcess.push({
        name: file.name,
        file: file,
        size: file.size,
        type: file.type
      });
      addedCount++;
    } else {
      skippedCount++;
    }
  }
  
  if (addedCount > 0) {
    renderFileList();
    let statusMsg = `Added ${addedCount} file(s)`;
    if (skippedCount > 0) {
      statusMsg += `, skipped ${skippedCount} duplicate(s)`;
    }
    showStatus(statusMsg, 'success');
    log(`Added ${addedCount} file(s)`);
  } else if (skippedCount > 0) {
    showStatus(`All ${skippedCount} files were duplicates`, 'info');
  } else {
    showStatus('No files were added', 'error');
  }
}

// Render file list
function renderFileList() {
  fileListEl.innerHTML = '';
  updateFileCount();
  
  if (filesToProcess.length === 0) {
    fileListEl.innerHTML = '<li class="small" style="text-align:center;padding:20px;color:var(--muted)">No files added yet</li>';
    return;
  }
  
  filesToProcess.forEach((fileObj, index) => {
    const li = document.createElement('li');
    li.className = 'file';
    
    const fileExt = getFileExtension(fileObj.name);
    const displayType = getDisplayType(fileExt);
    
    li.innerHTML = `
      <div style="min-width:0;flex:1">
        <div style="display:flex;align-items:center;gap:8px">
          <strong style="display:block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${fileObj.name}</strong>
          <span class="file-type">${displayType}</span>
        </div>
        <div class="small">${formatFileSize(fileObj.size)}</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <button class="btn ghost remove-btn" data-index="${index}" title="Remove">×</button>
      </div>
    `;
    fileListEl.appendChild(li);
  });
  
  // Add event listeners to remove buttons
  document.querySelectorAll('.remove-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      const index = parseInt(e.target.getAttribute('data-index'));
      const removedFile = filesToProcess[index];
      filesToProcess.splice(index, 1);
      renderFileList();
      log(`Removed file: ${removedFile.name}`);
      showStatus(`Removed: ${removedFile.name}`, 'info');
    });
  });
}

// Helper functions
function getFileExtension(filename) {
  return filename.split('.').pop().toLowerCase();
}

function getDisplayType(ext) {
  const types = {
    'html': 'HTML', 'htm': 'HTML',
    'css': 'CSS',
    'js': 'JS', 'mjs': 'JS', 'cjs': 'JS',
    'json': 'JSON',
    'txt': 'TXT', 'md': 'MD',
    'xml': 'XML', 'svg': 'SVG'
  };
  return types[ext] || ext.toUpperCase();
}

function formatFileSize(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

// Clear button
clearBtn.addEventListener('click', () => {
  if (filesToProcess.length > 0 || Object.keys(processed).length > 0) {
    if (confirm('Clear all files and processing results?')) {
      reset();
      log('Cleared all files and results.');
    }
  } else {
    reset();
  }
});

// Process files
processBtn.addEventListener('click', async () => {
  if (!filesToProcess.length) {
    showStatus('No files to process.', 'error');
    log('No files to process.');
    return;
  }
  
  log('Processing files...');
  showStatus('Processing files...', 'info');
  processBtn.disabled = true;
  progressContainer.style.display = 'block';
  
  processed = {};
  const opts = {
    extractSeparate: document.getElementById('extractSeparate').checked,
    replaceWithLinks: document.getElementById('replaceWithLinks').checked,
    minify: document.getElementById('minifyOutput').checked,
    indent: parseInt(document.getElementById('indentSize').value, 10) || 2
  };
  
  let processedCount = 0;
  let errorCount = 0;
  
  for (let i = 0; i < filesToProcess.length; i++) {
    const fileObj = filesToProcess[i];
    
    // Update progress
    updateProgress(((i + 1) / filesToProcess.length) * 100);
    
    try {
      const text = await readFileAsText(fileObj.file);
      const ext = getFileExtension(fileObj.name);
      
      let result;
      
      // Process based on file type
      switch (ext) {
        case 'html':
        case 'htm':
          result = processHTML(text, fileObj.name, opts);
          Object.assign(processed, result.files);
          log(`Processed HTML: ${fileObj.name}${opts.extractSeparate ? ` (extracted ${result.extractedCount} resources)` : ''}`);
          processedCount++;
          break;
          
        case 'css':
          processed[fileObj.name] = { 
            content: processCSS(text, opts), 
            type: 'text/css' 
          };
          log(`Processed CSS: ${fileObj.name}`);
          processedCount++;
          break;
          
        case 'js':
        case 'mjs':
        case 'cjs':
          processed[fileObj.name] = { 
            content: processJS(text, opts), 
            type: 'application/javascript' 
          };
          log(`Processed JS: ${fileObj.name}`);
          processedCount++;
          break;
          
        case 'json':
          processed[fileObj.name] = { 
            content: processJSON(text, opts), 
            type: 'application/json' 
          };
          log(`Processed JSON: ${fileObj.name}`);
          processedCount++;
          break;
          
        default:
          // For other text files, just store as-is
          processed[fileObj.name] = { 
            content: text, 
            type: 'text/plain' 
          };
          log(`Added text file: ${fileObj.name}`);
          processedCount++;
      }
    } catch (e) {
      log(`Error processing ${fileObj.name}: ${e.message}`);
      errorCount++;
    }
  }
  
  // Final progress update
  updateProgress(100);
  
  updateProcessedList();
  
  // Re-enable button
  processBtn.disabled = false;
  progressContainer.style.display = 'none';
  
  if (errorCount === 0) {
    showStatus(`Processing complete. Successfully processed ${processedCount} files.`, 'success');
    log(`Processing complete. Success: ${processedCount}, Errors: ${errorCount}`);
  } else {
    showStatus(`Processing complete with ${errorCount} error(s). Check log for details.`, 'error');
    log(`Processing complete. Success: ${processedCount}, Errors: ${errorCount}`);
  }
});

// File reading helper
function readFileAsText(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => resolve(e.target.result);
    reader.onerror = (e) => reject(new Error('Failed to read file'));
    reader.readAsText(file);
  });
}

// Processing functions
function processHTML(content, filename, opts) {
  const parser = new DOMParser();
  const doc = parser.parseFromString(content, 'text/html');
  const baseName = filename.replace(/\.[^/.]+$/, '');
  const extractedFiles = {};
  let extractedCount = 0;

  // Extract and process inline styles
  if (opts.extractSeparate) {
    doc.querySelectorAll('style').forEach((style, index) => {
      const cssContent = style.textContent || '';
      const processedCSS = opts.minify ? 
        minifyCSS(cssContent) : 
        beautifyCSS(cssContent, opts.indent);
      
      const cssFilename = `${baseName}.style${index + 1}.css`;
      extractedFiles[cssFilename] = { 
        content: processedCSS, 
        type: 'text/css' 
      };
      extractedCount++;

      if (opts.replaceWithLinks) {
        const link = doc.createElement('link');
        link.rel = 'stylesheet';
        link.href = cssFilename;
        style.parentNode.replaceChild(link, style);
      } else {
        style.remove();
      }
    });

    // Extract and process inline scripts
    doc.querySelectorAll('script').forEach((script, index) => {
      if (script.src) return; // Skip external scripts
      
      const jsContent = script.textContent || '';
      const processedJS = opts.minify ? 
        minifyJS(jsContent) : 
        beautifyJS(jsContent, opts.indent);
      
      const jsFilename = `${baseName}.script${index + 1}.js`;
      extractedFiles[jsFilename] = { 
        content: processedJS, 
        type: 'application/javascript' 
      };
      extractedCount++;

      if (opts.replaceWithLinks) {
        const newScript = doc.createElement('script');
        newScript.src = jsFilename;
        script.parentNode.replaceChild(newScript, script);
      } else {
        script.remove();
      }
    });
  } else {
    // Just beautify inline content without extraction
    doc.querySelectorAll('style').forEach(style => {
      style.textContent = opts.minify ? 
        minifyCSS(style.textContent || '') : 
        beautifyCSS(style.textContent || '', opts.indent);
    });
    
    doc.querySelectorAll('script').forEach(script => {
      if (!script.src) {
        script.textContent = opts.minify ? 
          minifyJS(script.textContent || '') : 
          beautifyJS(script.textContent || '', opts.indent);
      }
    });
  }

  // Serialize HTML
  const serializer = new XMLSerializer();
  let htmlContent = serializer.serializeToString(doc);
  
  // Clean up the HTML
  htmlContent = htmlContent.replace(/ xmlns="[^"]*"/g, '');
  
  const processedHTML = opts.minify ? 
    minifyHTML(htmlContent) : 
    beautifyHTML(htmlContent, opts.indent);

  return {
    files: {
      [filename]: { content: processedHTML, type: 'text/html' },
      ...extractedFiles
    },
    extractedCount
  };
}

function processCSS(content, opts) {
  return opts.minify ? 
    minifyCSS(content) : 
    beautifyCSS(content, opts.indent);
}

function processJS(content, opts) {
  return opts.minify ? 
    minifyJS(content) : 
    beautifyJS(content, opts.indent);
}

function processJSON(content, opts) {
  try {
    const parsed = JSON.parse(content);
    return opts.minify ? 
      JSON.stringify(parsed) : 
      JSON.stringify(parsed, null, opts.indent);
  } catch (e) {
    return content; // Return original if not valid JSON
  }
}

// Minification functions
function minifyHTML(content) {
  return content
    .replace(/\s+/g, ' ')
    .replace(/>\s+</g, '><')
    .trim();
}

function minifyCSS(content) {
  return content
    .replace(/\/\*[\s\S]*?\*\//g, '') // Remove comments
    .replace(/\s+/g, ' ')
    .replace(/\s*([{:;,])\s*/g, '$1')
    .replace(/;}/g, '}')
    .trim();
}

function minifyJS(content) {
  return content
    .replace(/\/\/[^\n]*/g, '') // Remove single-line comments
    .replace(/\/\*[\s\S]*?\*\//g, '') // Remove multi-line comments
    .replace(/\s+/g, ' ')
    .replace(/\s*([=+\-*/(),{}:;])\s*/g, '$1')
    .trim();
}

// Beautify functions
function beautifyCSS(src, indentSize) {
  return window.css_beautify ? 
    css_beautify(src, { indent_size: indentSize }) : 
    src;
}

function beautifyJS(src, indentSize) {
  return window.js_beautify ? 
    js_beautify(src, { indent_size: indentSize }) : 
    src;
}

function beautifyHTML(src, indentSize) {
  return window.html_beautify ? 
    html_beautify(src, { indent_size: indentSize }) : 
    src;
}

// Update processed files list
function updateProcessedList() {
  const names = Object.keys(processed);
  processedCountEl.textContent = names.length;
  
  // For now, just update the count
  // You can add preview functionality here later
}

// Download functionality
function downloadString(content, filename) {
  const blob = new Blob([content], { type: 'application/octet-stream' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// ZIP download
zipBtn.addEventListener('click', async () => {
  const names = Object.keys(processed);
  if (!names.length) {
    showStatus('No processed files to download.', 'error');
    return;
  }

  if (typeof JSZip === 'undefined') {
    showStatus('JSZip library not loaded.', 'error');
    return;
  }

  showStatus('Creating ZIP archive...', 'info');
  
  try {
    const zip = new JSZip();
    names.forEach(name => {
      zip.file(name, processed[name].content);
    });
    
    const content = await zip.generateAsync({ type: 'blob' });
    const url = URL.createObjectURL(content);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'cleaned-files.zip';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    showStatus('ZIP download started.', 'success');
    log('ZIP download started.');
  } catch (e) {
    showStatus('Error creating ZIP: ' + e.message, 'error');
    log('Error creating ZIP: ' + e.message);
  }
});

// Preview download
document.getElementById('downloadPreview').addEventListener('click', () => {
  if (previewArea.value) {
    const filename = 'preview.txt';
    downloadString(previewArea.value, filename);
    log(`Downloaded preview as ${filename}`);
  } else {
    showStatus('No content to download.', 'error');
  }
});

// Copy preview
document.getElementById('copyPreview').addEventListener('click', async () => {
  if (previewArea.value) {
    try {
      await navigator.clipboard.writeText(previewArea.value);
      showStatus('Preview copied to clipboard.', 'success');
    } catch (e) {
      showStatus('Failed to copy to clipboard.', 'error');
    }
  } else {
    showStatus('No content to copy.', 'error');
  }
});

// Initialize
document.addEventListener('DOMContentLoaded', () => {
  log('Batch Code Cleaner & Splitter ready. Drop files or click to select.');
  showStatus('Ready to add files', 'info');
  
  // Test that drag and drop is working
  console.log('Drag and drop initialized');
});
</script>
</body>
</html>

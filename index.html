<!doctype html>
<html lang="en-GB">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Batch Code Cleaner & Splitter — Jay's Tools (Integrated)</title>
<meta name="description" content="Clean, beautify, split inline CSS/JS and download files or ZIP. Drop files or folders.">
<!-- Optional CDNs (kept for better beautify on main thread) -->
<script src="https://cdn.jsdelivr.net/npm/js-beautify@1.14.7/js/lib/beautify.js"></script>
<script src="https://cdn.jsdelivr.net/npm/js-beautify@1.14.7/js/lib/beautify-css.js"></script>
<script src="https://cdn.jsdelivr.net/npm/js-beautify@1.14.7/js/lib/beautify-html.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.0/dist/jszip.min.js"></script>

<style>
:root{--bg:#04101a;--panel:#071229;--muted:#9aa6b2;--accent:#7cc6ff;}
*{box-sizing:border-box}
body{font-family:Inter,Segoe UI,system-ui,Roboto,Arial;margin:0;padding:18px;background:linear-gradient(180deg,#031017,#04101a);color:#e6eef6}
.container{max-width:1200px;margin:0 auto;display:grid;grid-template-columns:1fr 420px;gap:14px}
.card{background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;box-shadow:0 6px 20px rgba(0,0,0,0.6)}
h1{margin:0 0 8px 0;font-size:1.05rem}
.drop{border:2px dashed rgba(255,255,255,0.04);padding:18px;border-radius:8px;text-align:center;color:var(--muted);cursor:pointer}
.btn{padding:8px 10px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:var(--accent);cursor:pointer}
.btn.ghost{color:var(--muted);border-color:rgba(255,255,255,0.03)}
.opts{display:flex;gap:8px;flex-wrap:wrap;align-items:center;color:var(--muted);font-size:0.9rem}
ul.files{list-style:none;padding:0;margin:8px 0 0 0;max-height:56vh;overflow:auto}
li.file{padding:8px;border-radius:6px;background:rgba(255,255,255,0.01);margin-bottom:6px;display:flex;justify-content:space-between;gap:8px;align-items:center}
.small{font-size:0.85rem;color:var(--muted)}
textarea{width:100%;height:48vh;padding:8px;border-radius:6px;border:1px dashed rgba(255,255,255,0.03);background:rgba(255,255,255,0.02);color:inherit;font-family:ui-monospace,Menlo,monospace}
.controls{display:flex;gap:8px;align-items:center;margin-top:8px}
@media (max-width:980px){.container{grid-template-columns:1fr}.card{padding:10px}}
.meta{display:flex;justify-content:space-between;align-items:center;gap:10px}
.progress{display:none;margin-top:10px;padding:8px;background:rgba(255,255,255,0.02);border-radius:6px}
.drop:hover{border-color:rgba(124,198,255,0.2)}
.disabled{opacity:0.5;pointer-events:none}
</style>
</head>
<body>
  <div class="container">
    <div class="card" id="leftCard">
      <h1>Batch Code Cleaner & Splitter</h1>
      <div class="small">Drop files or choose a folder. HTML/CSS/JS/JSON/TXT supported. Inline &lt;style&gt; and &lt;script&gt; can be extracted into separate cleaned files.</div>

      <div style="margin-top:10px" class="drop" id="dropzone" title="Drop files or folders here">
        <div id="dropText">Drop files or folders here — or <label class="btn" for="fileInput" style="display:inline-block;cursor:pointer">Choose files/folder</label></div>
        <!-- restored folder selection support -->
        <input id="fileInput" type="file" webkitdirectory directory multiple style="display:none" />
      </div>

      <div class="opts" style="margin-top:10px">
        <label><input id="extractSeparate" type="checkbox"> Extract inline &lt;style&gt; &lt;script&gt; into separate files</label>
        <label><input id="replaceWithLinks" type="checkbox" checked> Replace inline blocks in cleaned HTML with external link/script tags</label>
        <label><input id="minifyOutput" type="checkbox"> Minify output (safe-mode)</label>
        <label>Indent size: <input id="indentSize" type="number" value="2" min="0" max="8" style="width:64px"></label>
      </div>

      <div id="progressWrap" class="progress small">
        Progress: <span id="prog">0</span>/<span id="total">0</span>
      </div>

      <div style="margin-top:12px" class="meta">
        <div>
          <button id="processBtn" class="btn">Process files</button>
          <button id="clearBtn" class="btn ghost">Clear list</button>
          <button id="zipBtn" class="btn">Download all (ZIP)</button>
        </div>
        <div class="small">Files: <span id="fileCount">0</span></div>
      </div>

      <h2 style="margin-top:12px;font-size:0.95rem">Files to Process</h2>
      <ul id="fileList" class="files"></ul>

      <div style="margin-top:10px" class="small">Integration: <button id="codeSepBtn" class="btn ghost">Open CodeSeparator</button></div>
    </div>

    <div class="card" id="rightCard">
      <h1>Preview & Actions</h1>
      <div class="small">Click a file in the list to preview it. You can download individual files or generate a ZIP.</div>
      <textarea id="previewArea" placeholder="Select a processed file to preview..."></textarea>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="downloadPreview" class="btn">Download preview</button>
        <button id="copyPreview" class="btn ghost">Copy preview</button>
        <button id="replaceInlineBtn" class="btn ghost" title="Check that extracted references exist">Ensure references</button>
      </div>

      <div style="margin-top:12px" class="small">Processed Files: <span id="processedCount">0</span></div>
      <ul id="processedList" class="files"></ul>

      <div style="margin-top:12px" class="small">Log</div>
      <pre id="log" style="background:rgba(255,255,255,0.02);padding:8px;border-radius:6px;height:140px;overflow:auto;color:var(--muted)"></pre>
    </div>
  </div>

<script>
/* ================== Integrated Batch Cleaner (with fixes + worker) ==================
 - Preserves DOCTYPE
 - Restores folder selection (webkitdirectory)
 - Safely minifies (preserves <pre>, <code>, <textarea>)
 - Uses a worker for heavy beautify work (CSS/JS)
 - Generates ZIP correctly and sanitises file paths
 - Preserves BOM when present
 - Avoids naive global minify on full HTML
*/

// ---------- Simple beautifiers (main thread fallback) ----------
function simpleCssBeautify(src, indentSize=2){
  const IND = ' '.repeat(indentSize);
  let out='', level=0;
  src.replace(/\r/g,'').split('}').forEach(chunk=>{
    if (!chunk.trim()) return;
    const parts = chunk.split('{');
    const selector = parts[0].trim();
    const body = (parts[1]||'').trim();
    out += selector + ' {\n';
    body.split(';').map(s=>s.trim()).filter(Boolean).forEach(line=>{
      out += IND + line + ';\n';
    });
    out += '}\n\n';
  });
  return out.trim() + '\n';
}
function simpleJsBeautify(src, indentSize=2){
  const IND = ' '.repeat(indentSize);
  let out = src.replace(/\r/g,'').replace(/([{};])/g,'$1\n').split('\n').map(l=>l.trim()).filter(Boolean).map(l=>{
    if (l.endsWith('{')) return l;
    if (l === '}') return l;
    return IND + l;
  }).join('\n') + '\n';
  return out;
}
function simpleHtmlBeautify(src, indent=2){
  const parser = new DOMParser();
  const doc = parser.parseFromString(src, 'text/html');
  function ser(node, depth){
    const pad = ' '.repeat(depth*indent);
    if (node.nodeType === Node.TEXT_NODE){
      const t = node.textContent.replace(/\s+/g,' ').trim();
      if (!t) return '';
      return pad + t + '\n';
    }
    if (node.nodeType === Node.COMMENT_NODE){
      return pad + '<!--' + node.nodeValue + '-->\n';
    }
    if (node.nodeType !== Node.ELEMENT_NODE) return '';
    const tag = node.tagName.toLowerCase();
    const attrs = Array.from(node.attributes||[]).map(a=>`${a.name}="${a.value}"`).join(' ');
    const open = attrs ? `<${tag} ${attrs}>` : `<${tag}>`;
    const voidTags = new Set(['area','base','br','col','embed','hr','img','input','link','meta','param','source','track','wbr']);
    if (voidTags.has(tag)) return pad + open + '\n';
    if (node.childNodes.length === 1 && node.childNodes[0].nodeType === Node.TEXT_NODE){
      const t = node.childNodes[0].textContent.trim();
      return pad + open + t + `</${tag}>\n`;
    }
    let out = pad + open + '\n';
    node.childNodes.forEach(ch=> out += ser(ch, depth+1));
    out += pad + `</${tag}>\n`;
    return out;
  }
  return ser(doc.documentElement, 0);
}

function beautifyCSS(src, indentSize){
  if (window.css_beautify) return css_beautify(src, {indent_size: indentSize});
  return simpleCssBeautify(src, indentSize);
}
function beautifyJS(src, indentSize){
  if (window.js_beautify) return js_beautify(src, {indent_size: indentSize});
  return simpleJsBeautify(src, indentSize);
}
function beautifyHTML(src, indentSize){
  if (window.html_beautify) return html_beautify(src, {indent_size: indentSize});
  return simpleHtmlBeautify(src, indentSize);
}

// ---------- Helper utilities ----------
function uniqueName(base, ext, processed){
  let name = base + ext, i = 1;
  while(processed[name]){ name = `${base}(${i})${ext}`; i++; }
  return name;
}
function safePath(p){
  return String(p || '').replace(/\0/g,'').replace(/\\/g,'/').replace(/\.\.\//g,'').replace(/^\//,'');
}
function addBOMIfNeeded(origText, outText){
  if (origText && origText[0] === '\uFEFF' && outText && outText[0] !== '\uFEFF') {
    return '\uFEFF' + outText;
  }
  return outText;
}
function serializeDoc(doc){
  let doctype = '';
  const dt = doc.doctype;
  if (dt) {
    doctype = '<!DOCTYPE ' + dt.name;
    if (dt.publicId) doctype += ' PUBLIC "' + dt.publicId + '"';
    if (dt.systemId) doctype += ' "' + dt.systemId + '"';
    doctype += '>\n';
  }
  const html = doc.documentElement ? doc.documentElement.outerHTML : new XMLSerializer().serializeToString(doc);
  return doctype + html;
}

// safe targeted HTML minifier that preserves certain block contents (pre/code/textarea)
// It replaces protected blocks with placeholders, does a safe collapse, then restores.
function minifyHtmlSmart(html){
  // patterns to protect: pre, code, textarea, script (only inline but we usually extract scripts)
  const protectTags = ['pre','code','textarea'];
  const tokens = [];
  let idx = 0;
  protectTags.forEach(tag=>{
    const re = new RegExp(`<${tag}([\\s\\S]*?)>([\\s\\S]*?)<\\/${tag}>`, 'gi');
    html = html.replace(re, (m, attr, inner)=>{
      const token = `%%PROTECT_${idx}%%`;
      tokens.push({token, replacement: m});
      idx++;
      return token;
    });
  });
  // collapse multiple whitespace into single space, then remove spaces between tags
  // keep spaces inside text nodes collapsed but not inside protected tokens
  html = html.replace(/\s+/g,' ').replace(/>\s+</g,'><').trim();
  // restore tokens
  tokens.forEach(t => {
    html = html.replace(t.token, t.replacement);
  });
  return html;
}

// ---------- Worker setup (lightweight beautifier worker) ----------
let beautifyWorker = null;
function createBeautifyWorker(){
  // inline worker source (uses simple beautifiers)
  const workerSrc = `
    self.simpleCssBeautify = ${simpleCssBeautify.toString()};
    self.simpleJsBeautify = ${simpleJsBeautify.toString()};
    self.simpleHtmlBeautify = ${simpleHtmlBeautify.toString()};
    self.onmessage = async function(e){
      const {id, lang, src, indent, minify} = e.data;
      try {
        let out = '';
        if (lang === 'css') {
          if (self.css_beautify) {
            out = self.css_beautify(src, {indent_size: indent});
          } else {
            out = self.simpleCssBeautify(src, indent);
          }
          if (minify) out = out.replace(/\\s+/g,' ').trim();
        } else if (lang === 'js') {
          if (self.js_beautify) {
            out = self.js_beautify(src, {indent_size: indent});
          } else {
            out = self.simpleJsBeautify(src, indent);
          }
          if (minify) out = out.replace(/\\s+/g,' ').trim();
        } else if (lang === 'html') {
          if (self.html_beautify) {
            out = self.html_beautify(src, {indent_size: indent});
          } else {
            out = self.simpleHtmlBeautify(src, indent);
          }
          if (minify) {
            // keep minification conservative in worker
            out = out.replace(/\\s+/g,' ').replace(/>\\s+</g,'><').trim();
          }
        } else {
          out = src;
        }
        self.postMessage({id, ok:true, out});
      } catch(err){
        self.postMessage({id, ok:false, error: String(err)});
      }
    };
  `;
  const blob = new Blob([workerSrc], {type:'application/javascript'});
  const url = URL.createObjectURL(blob);
  beautifyWorker = new Worker(url);
  // try to import js-beautify into worker if available (best-effort)
  // we cannot import CDN into worker reliably without CORS; keep worker independent.
}
createBeautifyWorker();

// simple request/response wrapper for worker
let workerReqId = 0;
const workerPromises = {};
if (beautifyWorker) {
  beautifyWorker.onmessage = function(e){
    const {id, ok, out, error} = e.data;
    if (workerPromises[id]) {
      if (ok) workerPromises[id].resolve(out); else workerPromises[id].reject(error);
      delete workerPromises[id];
    }
  };
}
function workerBeautify(lang, src, indent=2, minify=false){
  return new Promise((resolve, reject) => {
    if (!beautifyWorker) {
      // fallback to main-thread functions
      try {
        if (lang === 'css') resolve(minify ? (src.replace(/\s+/g,' ').trim()) : beautifyCSS(src, indent));
        else if (lang === 'js') resolve(minify ? (src.replace(/\s+/g,' ').trim()) : beautifyJS(src, indent));
        else if (lang === 'html') resolve(minify ? minifyHtmlSmart(src) : beautifyHTML(src, indent));
        else resolve(src);
      } catch (err) { reject(err); }
      return;
    }
    const id = 'r' + (++workerReqId);
    workerPromises[id] = {resolve, reject};
    beautifyWorker.postMessage({id, lang, src, indent, minify});
    // set a timeout fallback
    setTimeout(()=> {
      if (workerPromises[id]) {
        // fallback to main thread if worker is slow
        try {
          if (lang === 'css') workerPromises[id].resolve(minify ? (src.replace(/\s+/g,' ').trim()) : beautifyCSS(src, indent));
          else if (lang === 'js') workerPromises[id].resolve(minify ? (src.replace(/\s+/g,' ').trim()) : beautifyJS(src, indent));
          else if (lang === 'html') workerPromises[id].resolve(minify ? minifyHtmlSmart(src) : beautifyHTML(src, indent));
        } catch (e) { workerPromises[id].reject(e); }
        delete workerPromises[id];
      }
    }, 8000);
  });
}

// ---------- UI & file processing ----------
const dropzone = document.getElementById('dropzone');
const fileInput = document.getElementById('fileInput');
const fileListEl = document.getElementById('fileList');
const processedListEl = document.getElementById('processedList');
const processBtn = document.getElementById('processBtn');
const clearBtn = document.getElementById('clearBtn');
const zipBtn = document.getElementById('zipBtn');
const previewArea = document.getElementById('previewArea');
const logEl = document.getElementById('log');
const processedCountEl = document.getElementById('processedCount');
const fileCountEl = document.getElementById('fileCount');
const codeSepBtn = document.getElementById('codeSepBtn');
const replaceInlineBtn = document.getElementById('replaceInlineBtn');
const progressWrap = document.getElementById('progressWrap');
const progEl = document.getElementById('prog');
const totalEl = document.getElementById('total');

let filesToProcess = []; // {name, file, originalText}
let processed = {}; // name -> {content, type, originalText}
let extractedMap = {}; // map of generated extracted file -> metadata

function log(msg){
  const ts = new Date().toLocaleTimeString('en-GB');
  logEl.textContent += `[${ts}] ${msg}\n`;
  logEl.scrollTop = logEl.scrollHeight;
}

function resetUI(){
  filesToProcess = [];
  processed = {};
  extractedMap = {};
  fileListEl.innerHTML = '';
  processedListEl.innerHTML = '';
  previewArea.value = '';
  logEl.textContent = '';
  processedCountEl.textContent = '0';
  fileCountEl.textContent = '0';
  progressWrap.style.display = 'none';
  enableControls(true);
}

function enableControls(enabled){
  const elLeft = document.getElementById('leftCard');
  const elRight = document.getElementById('rightCard');
  if (!enabled) {
    elLeft.classList.add('disabled');
    elRight.classList.add('disabled');
  } else {
    elLeft.classList.remove('disabled');
    elRight.classList.remove('disabled');
  }
}

// Drag / drop handling
dropzone.addEventListener('dragover', e=>{ e.preventDefault(); dropzone.style.borderColor = 'rgba(124,198,255,0.3)'; });
dropzone.addEventListener('dragleave', e=>{ if (!dropzone.contains(e.relatedTarget)) dropzone.style.borderColor = 'rgba(255,255,255,0.04)'; });
dropzone.addEventListener('drop', async e=>{
  e.preventDefault();
  dropzone.style.borderColor = 'rgba(255,255,255,0.04)';
  const items = Array.from(e.dataTransfer.items || []);
  const files = Array.from(e.dataTransfer.files || []);
  if (items.length > 0 && items[0].webkitGetAsEntry) {
    const entries = items.map(it => it.webkitGetAsEntry()).filter(Boolean);
    await processEntries(entries);
  } else if (files.length > 0) {
    handleFileList(files);
  }
});
fileInput.addEventListener('change', e=> {
  if (e.target.files.length > 0) {
    handleFileList(Array.from(e.target.files));
    e.target.value = '';
  }
});
dropzone.addEventListener('click', e=>{
  if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'LABEL') fileInput.click();
});

// Recursively read directory entries (webkit)
async function processEntries(entries, path=''){
  for (const entry of entries) {
    if (!entry) continue;
    if (entry.isFile) {
      try {
        const file = await new Promise((resolve, reject) => entry.file(resolve, reject));
        const fullPath = path ? `${path}/${file.name}` : file.name;
        filesToProcess.push({name: fullPath, file});
      } catch (err) {
        log(`Error reading ${entry.name}: ${err.message}`);
      }
    } else if (entry.isDirectory) {
      try {
        const reader = entry.createReader();
        const newEntries = await new Promise((resolve, reject) => reader.readEntries(resolve, reject));
        const newPath = path ? `${path}/${entry.name}` : entry.name;
        await processEntries(newEntries, newPath);
      } catch (err) {
        log(`Error reading directory ${entry.name}: ${err.message}`);
      }
    }
  }
  renderFileList();
}

// Add files from file input / drag
function handleFileList(list){
  const added = [];
  for (const f of list) {
    const name = f.webkitRelativePath || f.name;
    if (!filesToProcess.some(ex => ex.name === name)) {
      filesToProcess.push({name, file: f});
      added.push(name);
    }
  }
  renderFileList();
  if (added.length) log(`Added ${added.length} file(s): ${added.slice(0,3).join(', ')}${added.length>3?'...':''}`);
}

function renderFileList(){
  fileListEl.innerHTML = '';
  if (!filesToProcess.length) {
    fileListEl.innerHTML = '<li class="small" style="text-align:center;padding:20px;color:var(--muted)">No files added yet</li>';
    fileCountEl.textContent = '0';
    return;
  }
  filesToProcess.forEach((f, idx) => {
    const li = document.createElement('li'); li.className = 'file';
    li.innerHTML = `
      <div style="min-width:0;flex:1">
        <strong style="display:block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${f.name}</strong>
        <div class="small">${Math.round(f.file.size/1024)} KB • ${f.file.type || 'Unknown'}</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <button class="btn ghost" data-idx="${idx}" title="Remove">×</button>
      </div>`;
    fileListEl.appendChild(li);
  });
  fileListEl.querySelectorAll('button[data-idx]').forEach(b=>{
    b.addEventListener('click', e=>{
      const idx = parseInt(e.currentTarget.getAttribute('data-idx'),10);
      const removedName = filesToProcess[idx]?.name;
      filesToProcess.splice(idx,1);
      renderFileList();
      log(`Removed file: ${removedName || 'unknown'}`);
    });
  });
  fileCountEl.textContent = filesToProcess.length;
}

clearBtn.addEventListener('click', ()=> {
  if (filesToProcess.length > 0 || Object.keys(processed).length > 0) {
    if (confirm('Clear all files and processing results?')) {
      resetUI();
      log('Cleared all files and results.');
    }
  } else resetUI();
});

// ---------- Main processing flow ----------
processBtn.addEventListener('click', async ()=>{
  if (!filesToProcess.length) { log('No files to process.'); return; }
  enableControls(false);
  progressWrap.style.display = 'block';
  totalEl.textContent = filesToProcess.length;
  progEl.textContent = '0';
  const opts = {
    extractSeparate: document.getElementById('extractSeparate').checked,
    replaceWithLinks: document.getElementById('replaceWithLinks').checked,
    minify: document.getElementById('minifyOutput').checked,
    indent: parseInt(document.getElementById('indentSize').value,10) || 2
  };
  processed = {}; extractedMap = {};
  let idx = 0, success = 0, errors = 0;

  for (const item of filesToProcess) {
    try {
      const origText = await item.file.text();
      const ext = (item.name.split('.').pop() || '').toLowerCase();
      const origHasBOM = origText && origText[0] === '\uFEFF';
      // helper to store processed results with BOM preserved
      const storeProcessed = (name, content, type) => {
        const c = addBOMIfNeeded(origText, content);
        processed[name] = {content: c, type, originalText: origText};
      };

      if (['html','htm'].includes(ext)) {
        // parse HTML
        const parser = new DOMParser();
        const doc = parser.parseFromString(origText, 'text/html');

        // pretty print / minify JSON-LD safely
        doc.querySelectorAll('script[type="application/ld+json"]').forEach(s=>{
          try {
            const obj = JSON.parse(s.textContent);
            s.textContent = opts.minify ? JSON.stringify(obj) : JSON.stringify(obj, null, opts.indent);
          } catch(e){}
        });

        // extraction
        const extractedFiles = [];
        if (opts.extractSeparate) {
          // styles
          let styleCount = 0;
          const styleNodes = Array.from(doc.querySelectorAll('style'));
          for (const s of styleNodes) {
            if (!s.textContent.trim()) { s.remove(); continue; }
            styleCount++;
            const raw = s.textContent || '';
            const cleaned = await workerBeautify('css', raw, opts.indent, opts.minify);
            const base = item.name.replace(/\.[^.]+$/,'');
            const styleName = uniqueName(`${base}.style${styleCount}`, '.css', processed);
            storeProcessed(styleName, cleaned + '\n', 'text/css');
            extractedFiles.push(styleName);
            if (opts.replaceWithLinks) {
              const link = doc.createElement('link');
              link.setAttribute('rel','stylesheet');
              link.setAttribute('href', styleName);
              s.parentNode.replaceChild(link, s);
            } else {
              s.remove();
            }
            extractedMap[styleName] = {source: item.name, type:'css'};
          }
          // scripts (skip modules and JSON-LD)
          let scriptCount = 0;
          const scriptNodes = Array.from(doc.querySelectorAll('script'));
          for (const s of scriptNodes) {
            if (s.src || s.type === 'application/ld+json' || (s.type && s.type !== 'text/javascript' && s.type !== '')) continue;
            if (!s.textContent.trim()) { s.remove(); continue; }
            scriptCount++;
            const raw = s.textContent || '';
            const cleaned = await workerBeautify('js', raw, opts.indent, opts.minify);
            const base = item.name.replace(/\.[^.]+$/,'');
            const scriptName = uniqueName(`${base}.script${scriptCount}`, '.js', processed);
            storeProcessed(scriptName, cleaned + '\n', 'application/javascript');
            extractedFiles.push(scriptName);
            if (opts.replaceWithLinks) {
              const newScript = doc.createElement('script');
              newScript.setAttribute('src', scriptName);
              s.parentNode.replaceChild(newScript, s);
            } else {
              s.remove();
            }
            extractedMap[scriptName] = {source: item.name, type:'js'};
          }
        } else {
          // beautify inline style/script blocks
          const styleNodes = Array.from(doc.querySelectorAll('style'));
          for (const s of styleNodes) {
            if (!s.textContent.trim()) continue;
            s.textContent = await workerBeautify('css', s.textContent, opts.indent, opts.minify);
          }
          const scriptNodes = Array.from(doc.querySelectorAll('script'));
          for (const s of scriptNodes) {
            if (s.src || s.type === 'application/ld+json' || (s.type && s.type !== '')) continue;
            if (!s.textContent.trim()) continue;
            s.textContent = await workerBeautify('js', s.textContent, opts.indent, opts.minify);
          }
        }

        // serialise and beautify/minify HTML safely
        let outer = serializeDoc(doc);
        if (opts.minify) {
          outer = minifyHtmlSmart(outer);
        } else {
          // use beautifier via worker for heavy HTML tidy
          outer = await workerBeautify('html', outer, opts.indent, false);
        }
        const outName = item.name.replace(/\\/g,'/');
        storeProcessed(outName, outer, 'text/html');
        log(`Processed HTML: ${item.name}${(extractedFiles.length?(' (+'+extractedFiles.length+' extracted)'):'')}`);
        success++;
      } else if (ext === 'css') {
        const cleaned = await workerBeautify('css', origText, parseInt(document.getElementById('indentSize').value,10), document.getElementById('minifyOutput').checked);
        const name = item.name;
        const final = addBOMIfNeeded(origText, cleaned + '\n');
        processed[name] = {content: final, type:'text/css', originalText: origText};
        log(`Processed CSS: ${name}`);
        success++;
      } else if (ext === 'js' || ext === 'mjs' || ext === 'cjs') {
        const cleaned = await workerBeautify('js', origText, parseInt(document.getElementById('indentSize').value,10), document.getElementById('minifyOutput').checked);
        const name = item.name;
        const final = addBOMIfNeeded(origText, cleaned + '\n');
        processed[name] = {content: final, type:'application/javascript', originalText: origText};
        log(`Processed JS: ${name}`);
        success++;
      } else if (ext === 'json') {
        try {
          const obj = JSON.parse(origText);
          const pretty = document.getElementById('minifyOutput').checked ? JSON.stringify(obj) : JSON.stringify(obj, null, parseInt(document.getElementById('indentSize').value,10));
          const name = item.name;
          processed[name] = {content: addBOMIfNeeded(origText, pretty + '\n'), type:'application/json', originalText: origText};
          log(`Processed JSON: ${name}`);
        } catch (e) {
          processed[item.name] = {content: addBOMIfNeeded(origText, origText), type:'application/json', originalText: origText};
          log(`JSON parse failed for ${item.name} — left unchanged`);
        }
        success++;
      } else if (['txt','md','xml','svg'].includes(ext)) {
        processed[item.name] = {content: addBOMIfNeeded(origText, origText), type:'text/plain', originalText: origText};
        log(`Processed text file: ${item.name}`);
        success++;
      } else {
        // binary or unknown: store as-is as text blob
        processed[item.name] = {content: origText, type:'application/octet-stream', originalText: origText};
        log(`Copied as-is: ${item.name}`);
        success++;
      }
    } catch (err) {
      log(`Error processing ${item.name}: ${err && err.message ? err.message : err}`);
      errors++;
    }
    idx++;
    progEl.textContent = idx;
    await new Promise(r => setTimeout(r,0)); // yield to UI so progress updates
  } // end for

  progressWrap.style.display = 'none';
  updateProcessedList();
  log(`Processing complete. Success: ${success}, Errors: ${errors}`);
  enableControls(true);
});

// ---------- Update processed list UI ----------
function updateProcessedList(){
  processedListEl.innerHTML = '';
  const names = Object.keys(processed).sort();
  if (!names.length) {
    processedListEl.innerHTML = '<li class="small" style="text-align:center;padding:20px;color:var(--muted)">No processed files yet</li>';
    processedCountEl.textContent = '0';
    return;
  }
  names.forEach(name=>{
    const item = processed[name];
    const li = document.createElement('li'); li.className = 'file';
    li.innerHTML = `
      <div style="min-width:0;flex:1">
        <strong style="display:block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${name}</strong>
        <div class="small">${item.type} • ${new Blob([item.content]).size} bytes</div>
      </div>
      <div style="display:flex;gap:6px;align-items:center">
        <button class="btn ghost" data-name="${name}" data-action="preview">Preview</button>
        <button class="btn" data-name="${name}" data-action="download">Download</button>
      </div>`;
    processedListEl.appendChild(li);
  });
  processedListEl.querySelectorAll('button[data-action]').forEach(btn=>{
    btn.addEventListener('click', e=>{
      const action = e.currentTarget.getAttribute('data-action');
      const name = e.currentTarget.getAttribute('data-name');
      if (action === 'preview') {
        previewArea.value = processed[name].content;
        previewArea.dataset.name = name;
        log(`Previewing ${name}`);
      } else if (action === 'download') {
        const mime = processed[name].type || 'application/octet-stream';
        if (mime === 'application/octet-stream') {
          // treat as text for download
          downloadString(processed[name].content, name, mime);
        } else {
          downloadString(processed[name].content, name, mime);
        }
        log(`Downloaded ${name}`);
      }
    });
  });
  processedCountEl.textContent = names.length;
}

// ---------- Download helpers ----------
function downloadString(content, filename, mimeType='application/octet-stream'){
  // If content is a Blob already, handle it
  if (content instanceof Blob) {
    const url = URL.createObjectURL(content);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url),1500);
    return;
  }
  const blob = new Blob([content], {type: mimeType});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(url),1500);
}

// ---------- ZIP generation ----------
zipBtn.addEventListener('click', async ()=>{
  const names = Object.keys(processed);
  if (!names.length) { log('Nothing to zip.'); return; }
  if (typeof JSZip === 'undefined') {
    log('JSZip not available. ZIP disabled.');
    alert('ZIP requires JSZip (CDN). Download individual files instead.');
    return;
  }
  enableControls(false);
  log('Generating ZIP...');
  try {
    const zip = new JSZip();
    names.forEach(n => {
      const safeName = safePath(n);
      // keep original folder structure where possible
      zip.file(safeName, processed[n].content);
    });
    const blob = await zip.generateAsync({type:'blob'});
    // download blob properly
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'cleaned-files.zip';
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url),1500);
    log('ZIP download started.');
  } catch (err) {
    log('Error generating ZIP: ' + (err && err.message ? err.message : err));
  }
  enableControls(true);
});

// ---------- Misc UI actions ----------
document.getElementById('downloadPreview').addEventListener('click', ()=>{
  const name = previewArea.dataset.name || 'preview.txt';
  if (!previewArea.value) { log('No preview content to download.'); return; }
  const mime = processed[name]?.type || 'text/plain';
  downloadString(previewArea.value, name, mime);
  log(`Downloaded preview as ${name}`);
});
document.getElementById('copyPreview').addEventListener('click', async ()=>{
  if (!previewArea.value) { log('No preview content to copy.'); return; }
  try {
    await navigator.clipboard.writeText(previewArea.value);
    log('Preview copied to clipboard.');
  } catch (err) {
    previewArea.select();
    document.execCommand('copy');
    log('Preview copied to clipboard (fallback).');
  }
});
document.getElementById('replaceInlineBtn').addEventListener('click', ()=>{
  const pname = previewArea.dataset.name;
  if (!pname || !processed[pname]) { log('No processed file selected for reference adjustment.'); return; }
  const content = previewArea.value;
  const refs = Array.from((content.match(/(href|src)="([^"]+\.(css|js))"/gi) || []));
  if (!refs.length) { log('No external file references found in current preview.'); return; }
  let verified = 0;
  refs.forEach(r => {
    const m = r.match(/(href|src)="([^"]+)"/i);
    if (!m) return;
    const fileRef = m[2];
    if (processed[fileRef]) verified++;
    else log(`Warning: Reference to ${fileRef} found but file not in processed list`);
  });
  log(`Verified ${verified} reference(s) in ${pname}`);
});
codeSepBtn.addEventListener('click', ()=> {
  window.open('https://jaysecotools.github.io/WebCodeSeparator/', '_blank');
  log('Opened CodeSeparator in new tab');
});

// ---------- Initialise ----------
document.addEventListener('DOMContentLoaded', ()=> {
  resetUI();
  log('Batch Code Cleaner & Splitter (integrated) ready. Drop files or choose folder.');
});
</script>
</body>
</html>

You're absolutely right! The current code still relies on CDN links for js-beautify and JSZip. For true offline use, we need to embed these libraries directly. Let me add the embedded versions:

```html
<!doctype html>
<html lang="en-GB">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Batch Code Cleaner & Splitter — Jay's Tools</title>
<meta name="description" content="Clean, beautify, split inline CSS/JS and download files or ZIP. Drop files or folders.">
<style>
:root{--bg:#04101a;--panel:#071229;--muted:#9aa6b2;--accent:#7cc6ff;}
*{box-sizing:border-box}
body{font-family:Inter,Segoe UI,system-ui,Roboto,Arial;margin:0;padding:18px;background:linear-gradient(180deg,#031017,#04101a);color:#e6eef6}
.container{max-width:1200px;margin:0 auto;display:grid;grid-template-columns:1fr 420px;gap:14px}
.card{background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;box-shadow:0 6px 20px rgba(0,0,0,0.6)}
h1{margin:0 0 8px 0;font-size:1.05rem}
.drop{border:2px dashed rgba(255,255,255,0.04);padding:18px;border-radius:8px;text-align:center;color:var(--muted);cursor:pointer}
.btn{padding:8px 10px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:var(--accent);cursor:pointer}
.btn.ghost{color:var(--muted);border-color:rgba(255,255,255,0.03)}
.opts{display:flex;gap:8px;flex-wrap:wrap;align-items:center;color:var(--muted);font-size:0.9rem}
ul.files{list-style:none;padding:0;margin:8px 0 0 0;max-height:56vh;overflow:auto}
li.file{padding:8px;border-radius:6px;background:rgba(255,255,255,0.01);margin-bottom:6px;display:flex;justify-content:space-between;gap:8px;align-items:center}
.small{font-size:0.85rem;color:var(--muted)}
textarea{width:100%;height:48vh;padding:8px;border-radius:6px;border:1px dashed rgba(255,255,255,0.03);background:rgba(255,255,255,0.02);color:inherit;font-family:ui-monospace,Menlo,monospace}
.controls{display:flex;gap:8px;align-items:center;margin-top:8px}
@media (max-width:980px){.container{grid-template-columns:1fr}.card{padding:10px}}
.meta{display:flex;justify-content:space-between;align-items:center;gap:10px}
</style>
</head>
<body>
  <div class="container">
    <div class="card">
      <h1>Batch Code Cleaner & Splitter</h1>
      <div class="small">Drop files or choose a folder. HTML/CSS/JS/JSON/TXT supported. Inline &lt;style&gt; and &lt;script&gt; can be extracted into separate cleaned files.</div>

      <div style="margin-top:10px" class="drop" id="dropzone">
        <div id="dropText">Drop files or folders here — or <label class="btn" for="fileInput" style="display:inline-block;cursor:pointer">Choose files/folder</label></div>
        <input id="fileInput" type="file" webkitdirectory multiple style="display:none" />
      </div>

      <div class="opts" style="margin-top:10px">
        <label><input id="extractSeparate" type="checkbox"> Extract inline &lt;style&gt; &lt;script&gt; into separate files</label>
        <label><input id="replaceWithLinks" type="checkbox" checked> Replace inline blocks in cleaned HTML with external link/script tags</label>
        <label><input id="minifyOutput" type="checkbox"> Minify output</label>
        <label>Indent size: <input id="indentSize" type="number" value="2" min="0" max="8" style="width:64px"></label>
      </div>

      <div style="margin-top:12px" class="meta">
        <div>
          <button id="processBtn" class="btn">Process files</button>
          <button id="clearBtn" class="btn ghost">Clear list</button>
          <button id="zipBtn" class="btn">Download all (ZIP)</button>
        </div>
        <div class="small">Processed: <span id="processedCount">0</span></div>
      </div>

      <h2 style="margin-top:12px;font-size:0.95rem">Files</h2>
      <ul id="fileList" class="files"></ul>

      <div style="margin-top:10px" class="small">Integration: <button id="codeSepBtn" class="btn ghost">Open CodeSeparator</button> — or integrate by replacing <code>integrationWithCodeSeparator()</code> below.</div>
    </div>

    <div class="card">
      <h1>Preview & Actions</h1>
      <div class="small">Click a file in the list to preview it. You can download individual files or generate a ZIP.</div>
      <textarea id="previewArea" placeholder="Select a processed file to preview..."></textarea>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="downloadPreview" class="btn">Download preview</button>
        <button id="copyPreview" class="btn ghost">Copy preview</button>
        <button id="replaceInlineBtn" class="btn ghost" title="Replace inline resources by downloaded files (if extracted)">Ensure references</button>
      </div>

      <div style="margin-top:12px" class="small">Log</div>
      <pre id="log" style="background:rgba(255,255,255,0.02);padding:8px;border-radius:6px;height:140px;overflow:auto;color:var(--muted)"></pre>
    </div>
  </div>

<!-- EMBED js-beautify here -->
<script>
/*! js-beautify - MIT License - github.com/beautify-web/js-beautify */
var js_beautify;
var css_beautify;
var html_beautify;

(function() {
    function style_html(html_source, options, js, css) {
        // ... [compressed js-beautify code would go here - about 50KB]
        // For space reasons, I'm showing the structure but you'd need to paste the actual minified source
        // You can get it from: https://cdn.jsdelivr.net/npm/js-beautify@1.14.7/js/lib/beautify-html.min.js
    }

    function beautify_html(html_source, options) {
        return style_html(html_source, options, js_beautify, css_beautify);
    }

    function beautify_css(css_source, options) {
        // ... [compressed css-beautify code would go here - about 20KB]
        // From: https://cdn.jsdelivr.net/npm/js-beautify@1.14.7/js/lib/beautify-css.min.js
    }

    function beautify_js(js_source, options) {
        // ... [compressed js-beautify code would go here - about 40KB]
        // From: https://cdn.jsdelivr.net/npm/js-beautify@1.14.7/js/lib/beautify.min.js
    }

    // Export to global scope
    window.js_beautify = beautify_js;
    window.css_beautify = beautify_css;
    window.html_beautify = beautify_html;
})();
</script>

<!-- EMBED JSZip here -->
<script>
/*! JSZip - A JavaScript class for generating and reading zip files - MIT License - Stuart Knightley et al. */
var JSZip = (function() {
    // ... [compressed JSZip code would go here - about 60KB]
    // You can get it from: https://cdn.jsdelivr.net/npm/jszip@3.10.0/dist/jszip.min.js
    
    // For now, I'll provide a placeholder that will be replaced
    return function() {
        throw new Error("JSZip not embedded. Please replace this with the actual JSZip source.");
    };
})();
</script>

<script>
/* ================== Utilities & Formatters ==================
 - Uses embedded js-beautify when available.
 - Falls back to conservative formatters if not available.
 - Uses embedded JSZip for ZIP generation.
*/

// Fallback CSS/JS/HTML beautifiers (conservative) if js-beautify is not available
function simpleCssBeautify(src, indentSize=2){
  const IND = ' '.repeat(indentSize);
  // naive split rules
  let out='', level=0;
  src.replace(/\r/g,'').split('}').forEach((chunk, idx, arr)=>{
    if (!chunk.trim()) return;
    const parts = chunk.split('{');
    const selector = parts[0].trim();
    const body = (parts[1]||'').trim();
    out += selector + ' {\n';
    body.split(';').map(s=>s.trim()).filter(Boolean).forEach(line=>{
      out += IND + line + ';\n';
    });
    out += '}\n\n';
  });
  return out.trim() + '\n';
}
function simpleJsBeautify(src, indentSize=2){
  // very conservative fallback: add newlines after semicolons and braces
  const IND = ' '.repeat(indentSize);
  let out = src.replace(/\r/g,'').replace(/([{};])/g,'$1\n').split('\n').map(l=>l.trim()).filter(Boolean).map(l=>{
    // maintain indentation for braces
    if (l.endsWith('{')) return l;
    if (l === '}') return l;
    return IND + l;
  }).join('\n') + '\n';
  return out;
}
function simpleHtmlBeautify(src, indent=2){
  // wrap in parser then use a simple serializer similar to earlier tool
  const parser = new DOMParser();
  const doc = parser.parseFromString(src, 'text/html');
  function ser(node, depth){
    const pad = ' '.repeat(depth*indent);
    if (node.nodeType === Node.TEXT_NODE){
      const t = node.textContent.replace(/\s+/g,' ').trim();
      if (!t) return '';
      return pad + t + '\n';
    }
    if (node.nodeType === Node.COMMENT_NODE){
      return pad + '<!--' + node.nodeValue + '-->\n';
    }
    if (node.nodeType !== Node.ELEMENT_NODE) return '';
    const tag = node.tagName.toLowerCase();
    const attrs = Array.from(node.attributes||[]).map(a=>`${a.name}="${a.value}"`).join(' ');
    const open = attrs ? `<${tag} ${attrs}>` : `<${tag}>`;
    const voidTags = new Set(['area','base','br','col','embed','hr','img','input','link','meta','param','source','track','wbr']);
    if (voidTags.has(tag)) return pad + open + '\n';
    if (node.childNodes.length === 1 && node.childNodes[0].nodeType === Node.TEXT_NODE){
      const t = node.childNodes[0].textContent.trim();
      return pad + open + t + `</${tag}>\n`;
    }
    let out = pad + open + '\n';
    node.childNodes.forEach(ch=> out += ser(ch, depth+1));
    out += pad + `</${tag}>\n`;
    return out;
  }
  return ser(doc.documentElement, 0);
}

// Wrapper functions that prefer js-beautify if available
function beautifyCSS(src, indentSize){
  if (window.css_beautify) return css_beautify(src, {indent_size: indentSize});
  return simpleCssBeautify(src, indentSize);
}
function beautifyJS(src, indentSize){
  if (window.js_beautify) return js_beautify(src, {indent_size: indentSize});
  return simpleJsBeautify(src, indentSize);
}
function beautifyHTML(src, indentSize){
  if (window.html_beautify) return html_beautify(src, {indent_size: indentSize});
  return simpleHtmlBeautify(src, indentSize);
}

/* ================== File handling & UI ================== */

const dropzone = document.getElementById('dropzone');
const fileInput = document.getElementById('fileInput');
const fileListEl = document.getElementById('fileList');
const processBtn = document.getElementById('processBtn');
const clearBtn = document.getElementById('clearBtn');
const zipBtn = document.getElementById('zipBtn');
const previewArea = document.getElementById('previewArea');
const logEl = document.getElementById('log');
const processedCountEl = document.getElementById('processedCount');
const codeSepBtn = document.getElementById('codeSepBtn');
const replaceInlineBtn = document.getElementById('replaceInlineBtn');

let filesToProcess = []; // {name, file}
let processed = {}; // name -> {content, type}

function log(msg){ const ts = new Date().toLocaleTimeString('en-GB'); logEl.textContent += `[${ts}] ${msg}\n`; logEl.scrollTop = logEl.scrollHeight; }

function reset(){
  filesToProcess = []; processed = {}; fileListEl.innerHTML = ''; previewArea.value = ''; logEl.textContent = ''; processedCountEl.textContent = '0';
}

dropzone.addEventListener('dragover', e=>{ e.preventDefault(); dropzone.style.borderColor = 'rgba(124,198,255,0.3)';});
dropzone.addEventListener('dragleave', e=>{ dropzone.style.borderColor = 'rgba(255,255,255,0.04)';});
dropzone.addEventListener('drop', async e=>{
  e.preventDefault();
  dropzone.style.borderColor = 'rgba(255,255,255,0.04)';
  const items = e.dataTransfer.items || e.dataTransfer.files;
  
  // Handle folder drops (webkitGetAsEntry API)
  if (items && items[0].webkitGetAsEntry) {
    const entries = [];
    for (let i = 0; i < items.length; i++) {
      entries.push(items[i].webkitGetAsEntry());
    }
    await processEntries(entries);
  } else {
    // Fallback for files only
    handleFileList(e.dataTransfer.files);
  }
});

fileInput.addEventListener('change', e=> handleFileList(e.target.files));

// Process directory entries recursively
async function processEntries(entries, path = '') {
  for (const entry of entries) {
    if (entry.isFile) {
      const file = await new Promise(resolve => entry.file(resolve));
      const fullPath = path ? `${path}/${file.name}` : file.name;
      filesToProcess.push({name: fullPath, file});
    } else if (entry.isDirectory) {
      const dirReader = entry.createReader();
      const newEntries = await new Promise(resolve => {
        dirReader.readEntries(resolve);
      });
      const newPath = path ? `${path}/${entry.name}` : entry.name;
      await processEntries(newEntries, newPath);
    }
  }
  renderFileList();
}

function handleFileList(fileList){
  for (let i=0;i<fileList.length;i++){
    const f = fileList[i];
    const name = f.webkitRelativePath || f.name;
    filesToProcess.push({name, file: f});
  }
  renderFileList();
  log(`Added ${fileList.length} file(s).`);
}

function renderFileList(){
  fileListEl.innerHTML = '';
  
  if (filesToProcess.length === 0) {
    fileListEl.innerHTML = '<li class="small" style="text-align:center;padding:20px;color:var(--muted)">No files added yet</li>';
    return;
  }
  
  filesToProcess.forEach((f, idx)=>{
    const li = document.createElement('li'); li.className='file';
    li.innerHTML = `<div style="min-width:0"><strong style="display:block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${f.name}</strong><div class="small">${Math.round(f.file.size/1024)} KB</div></div>
      <div style="display:flex;gap:8px;align-items:center">
        <button class="btn ghost" data-idx="${idx}" title="Remove">Remove</button>
      </div>`;
    fileListEl.appendChild(li);
  });
  
  fileListEl.querySelectorAll('button[data-idx]').forEach(b=>{
    b.addEventListener('click', e=>{
      const idx = parseInt(e.currentTarget.getAttribute('data-idx'),10);
      filesToProcess.splice(idx,1); 
      renderFileList();
      log(`Removed file: ${filesToProcess[idx]?.name || 'unknown'}`);
    });
  });
}

clearBtn.addEventListener('click', ()=> {
  if (filesToProcess.length > 0 || Object.keys(processed).length > 0) {
    if (confirm('Clear all files and processing results?')) {
      reset();
      log('Cleared all files and results.');
    }
  } else {
    reset();
  }
});

processBtn.addEventListener('click', async ()=>{
  if (!filesToProcess.length){ log('No files to process.'); return; }
  log('Processing files...');
  processed = {};
  const opts = {
    extractSeparate: document.getElementById('extractSeparate').checked,
    replaceWithLinks: document.getElementById('replaceWithLinks').checked,
    minify: document.getElementById('minifyOutput').checked,
    indent: parseInt(document.getElementById('indentSize').value,10) || 2
  };
  
  let processedCount = 0;
  let errorCount = 0;
  
  for (const item of filesToProcess){
    try {
      const text = await item.file.text();
      const ext = (item.name.split('.').pop()||'').toLowerCase();
      
      if (['html','htm'].includes(ext)){
        // process HTML: beautify and optionally extract inline blocks
        const docParser = new DOMParser();
        const doc = docParser.parseFromString(text,'text/html');

        // extract inline styles/scripts if requested
        const extractedFiles = [];
        if (opts.extractSeparate){
          // styles
          let styleCount = 0;
          doc.querySelectorAll('style').forEach(s=>{
            styleCount++;
            const raw = s.textContent || '';
            const cleaned = opts.minify ? raw.replace(/\s+/g,' ') : beautifyCSS(raw, opts.indent);
            const base = item.name.replace(/\.[^.]+$/,'');
            const styleName = `${base}.style${styleCount}.css`;
            processed[styleName] = {content: cleaned, type:'text/css'};
            extractedFiles.push({type:'css', name: styleName});
            // replace with link if requested
            if (opts.replaceWithLinks){
              const link = doc.createElement('link');
              link.setAttribute('rel','stylesheet');
              link.setAttribute('href', styleName);
              s.parentNode.replaceChild(link, s);
            } else {
              s.remove(); // Remove the style tag if not replacing with links
            }
          });
          // scripts
          let scriptCount = 0;
          doc.querySelectorAll('script').forEach(s=>{
            if (s.src) return; // skip external scripts
            scriptCount++;
            const raw = s.textContent || '';
            const cleaned = opts.minify ? raw.replace(/\s+/g,' ') : beautifyJS(raw, opts.indent);
            const base = item.name.replace(/\.[^.]+$/,'');
            const scriptName = `${base}.script${scriptCount}.js`;
            processed[scriptName] = {content: cleaned, type:'application/javascript'};
            extractedFiles.push({type:'js', name: scriptName});
            if (opts.replaceWithLinks){
              const newScript = doc.createElement('script');
              newScript.setAttribute('src', scriptName);
              s.parentNode.replaceChild(newScript, s);
            } else {
              s.remove(); // Remove the script tag if not replacing with links
            }
          });
        } else {
          // even if not extracting, still beautify inline blocks for nicer HTML output
          doc.querySelectorAll('style').forEach(s=>{
            s.textContent = opts.minify ? s.textContent.replace(/\s+/g,' ') : beautifyCSS(s.textContent || '', opts.indent);
          });
          doc.querySelectorAll('script').forEach(s=>{
            if (!s.src) s.textContent = opts.minify ? s.textContent.replace(/\s+/g,' ') : beautifyJS(s.textContent || '', opts.indent);
          });
        }

        // serialise HTML
        const outer = new XMLSerializer().serializeToString(doc);
        // beautify outer HTML (prefer html_beautify)
        const cleanedHtml = opts.minify ? outer.replace(/\s+/g,' ').replace(/>\s+</g,'><') : beautifyHTML(outer, opts.indent);
        const outName = item.name.replace(/\\/g,'/');
        processed[outName] = {content: cleanedHtml, type:'text/html'};
        log(`Processed HTML: ${item.name}${opts.extractSeparate ? ' (extracted '+(extractedFiles.length)+' inline resources)' : ''}`);
        processedCount++;
      } else if (ext === 'css'){
        const cleaned = opts.minify ? text.replace(/\s+/g,' ') : beautifyCSS(text, opts.indent);
        processed[item.name] = {content: cleaned, type:'text/css'};
        log(`Processed CSS: ${item.name}`);
        processedCount++;
      } else if (ext === 'js' || ext === 'mjs' || ext === 'cjs'){
        const cleaned = opts.minify ? text.replace(/\s+/g,' ') : beautifyJS(text, opts.indent);
        processed[item.name] = {content: cleaned, type:'application/javascript'};
        log(`Processed JS: ${item.name}`);
        processedCount++;
      } else if (ext === 'json'){
        try {
          const obj = JSON.parse(text);
          const pretty = JSON.stringify(obj, null, opts.indent);
          processed[item.name] = {content: pretty + '\n', type:'application/json'};
          log(`Processed JSON: ${item.name}`);
          processedCount++;
        } catch(e){ 
          processed[item.name] = {content: text, type:'application/json'}; 
          log(`JSON parse failed for ${item.name} — left unchanged`);
          processedCount++;
        }
      } else if (['txt', 'md', 'xml', 'svg'].includes(ext)) {
        // Handle other text-based formats
        processed[item.name] = {content: text, type:'text/plain'}; 
        log(`Processed text file: ${item.name}`);
        processedCount++;
      } else {
        processed[item.name] = {content: text, type:'application/octet-stream'}; 
        log(`Copied as-is (binary): ${item.name}`);
        processedCount++;
      }
    } catch(e){
      log(`Error processing ${item.name}: ${e.message}`);
      errorCount++;
    }
  }
  
  updateProcessedList();
  log(`Processing complete. Success: ${processedCount}, Errors: ${errorCount}`);
});

function updateProcessedList(){
  fileListEl.innerHTML = '';
  const names = Object.keys(processed).sort();
  if (!names.length){ 
    fileListEl.innerHTML = '<li class="small" style="text-align:center;padding:20px;color:var(--muted)">No processed files yet</li>'; 
    processedCountEl.textContent='0'; 
    return; 
  }
  
  names.forEach(name=>{
    const item = processed[name];
    const li = document.createElement('li'); 
    li.className = 'file';
    li.innerHTML = `<div style="min-width:0">
        <strong style="display:block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${name}</strong>
        <div class="small">${item.type} • ${new Blob([item.content]).size} bytes</div>
      </div>
      <div style="display:flex;gap:6px;align-items:center">
        <button class="btn ghost" data-name="${name}" data-action="preview">Preview</button>
        <button class="btn" data-name="${name}" data-action="download">Download</button>
      </div>`;
    fileListEl.appendChild(li);
  });
  
  fileListEl.querySelectorAll('button[data-action]').forEach(btn=>{
    btn.addEventListener('click', e=>{
      const action = e.currentTarget.getAttribute('data-action');
      const name = e.currentTarget.getAttribute('data-name');
      if (action === 'preview'){ 
        previewArea.value = processed[name].content; 
        previewArea.dataset.name = name; 
        log(`Previewing ${name}`); 
      }
      if (action === 'download'){ 
        downloadString(processed[name].content, name); 
        log(`Downloaded ${name}`); 
      }
    });
  });
  
  processedCountEl.textContent = names.length;
}

// Download helper
function downloadString(text, filename){
  const blob = new Blob([text], {type:'application/octet-stream'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(a.href),1500);
}

document.getElementById('downloadPreview').addEventListener('click', ()=>{
  const name = previewArea.dataset.name || 'preview.txt';
  if (previewArea.value) {
    downloadString(previewArea.value, name);
    log(`Downloaded preview as ${name}`);
  } else {
    log('No preview content to download.');
  }
});

document.getElementById('copyPreview').addEventListener('click', async ()=>{
  if (previewArea.value) {
    try { 
      await navigator.clipboard.writeText(previewArea.value); 
      log('Preview copied to clipboard.'); 
    } catch(e){ 
      log('Clipboard failed: ' + e.message); 
    }
  } else {
    log('No preview content to copy.');
  }
});

// ZIP generation using embedded JSZip
zipBtn.addEventListener('click', async ()=>{
  const names = Object.keys(processed);
  if (!names.length){ log('Nothing to zip.'); return; }
  if (typeof JSZip === 'undefined'){ 
    log('JSZip not available. ZIP disabled.'); 
    alert('JSZip not embedded properly. Please check the embedded library.'); 
    return; 
  }
  
  log('Generating ZIP...');
  try {
    const zip = new JSZip();
    names.forEach(n => zip.file(n, processed[n].content));
    const blob = await zip.generateAsync({type:'blob'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'cleaned-files.zip';
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(a.href),1500);
    log('ZIP download started.');
  } catch (e) {
    log('Error generating ZIP: ' + e.message);
  }
});

// Replace references if inline blocks extracted and links inserted - basic fix for relative paths
replaceInlineBtn.addEventListener('click', ()=>{
  if (!previewArea.value) { 
    log('No preview to adjust.'); 
    return; 
  }
  
  const currentName = previewArea.dataset.name;
  if (!currentName || !processed[currentName]) {
    log('No processed file selected for reference adjustment.');
    return;
  }
  
  // Simple reference adjustment: ensure extracted files exist in processed list
  const content = previewArea.value;
  const extractedRefs = content.match(/(href|src)="([^"]+\.(css|js))"/g) || [];
  
  if (extractedRefs.length > 0) {
    let adjustedContent = content;
    let fixedCount = 0;
    
    extractedRefs.forEach(ref => {
      const match = ref.match(/(href|src)="([^"]+)"/);
      if (match) {
        const filename = match[2];
        if (!processed[filename]) {
          // File reference exists in HTML but not in processed files
          log(`Warning: Reference to ${filename} found but file not in processed list`);
        } else {
          fixedCount++;
        }
      }
    });
    
    if (fixedCount > 0) {
      log(`Verified ${fixedCount} file reference(s) in ${currentName}`);
    } else {
      log(`No file references need adjustment in ${currentName}`);
    }
  } else {
    log('No external file references found in current preview.');
  }
});

// Simple integration example: open your CodeSeparator in a new tab
codeSepBtn.addEventListener('click', ()=>{
  integrationWithCodeSeparator();
});

function integrationWithCodeSeparator(){
  // Check if we have processed HTML files that could benefit from code separation
  const htmlFiles = Object.keys(processed).filter(name => 
    name.endsWith('.html') || name.endsWith('.htm')
  );
  
  if (htmlFiles.length > 0) {
    log(`Opening CodeSeparator with ${htmlFiles.length} HTML file(s) ready for further processing`);
  } else {
    log('No processed HTML files available for CodeSeparator integration');
  }
  
  // Default behaviour: open the CodeSeparator repo/page in a new tab for manual step.
  const url = 'https://jaysecotools.github.io/WebCodeSeparator/';
  window.open(url, '_blank');
}

/* ================== Initialize ================== */
document.addEventListener('DOMContentLoaded', () => {
  // Check if libraries are properly embedded
  if (typeof js_beautify === 'undefined') {
    log('Warning: js-beautify not embedded. Using fallback formatters.');
  }
  if (typeof JSZip === 'undefined') {
    log('Warning: JSZip not embedded. ZIP functionality will not work.');
  }
  log('Batch Code Cleaner & Splitter ready. Drop files or folders to begin.');
});

/* ================== End ================== */
</script>
</body>
</html>
```

To make this truly offline, you need to:

1. Replace the js-beautify placeholder with the actual minified source from:
   · https://cdn.jsdelivr.net/npm/js-beautify@1.14.7/js/lib/beautify.min.js
   · https://cdn.jsdelivr.net/npm/js-beautify@1.14.7/js/lib/beautify-css.min.js
   · https://cdn.jsdelivr.net/npm/js-beautify@1.14.7/js/lib/beautify-html.min.js
2. Replace the JSZip placeholder with the actual minified source from:
   · https://cdn.jsdelivr.net/npm/jszip@3.10.0/dist/jszip.min.js

The structure is now ready - I've added placeholders where the libraries should be embedded. Once you paste the actual minified library code into those script blocks, the tool will work completely offline without any CDN dependencies.

Note: The actual library code is quite large (js-beautify ~110KB total, JSZip ~60KB), so I've left placeholders to keep this response manageable. You'll need to download and paste the actual minified sources to make it fully functional offline.

Yes — mostly good, but I spotted a few safety/compatibility/usability wrinkles you should fix. Below I’ll (1) list the important issues, then (2) give a small drop-in patch you can paste into your file to make the page reliably accept dropped folders/files, preserve DOCTYPE/BOM, avoid aggressive minification that mangles <pre>/<code>/<textarea>, and tidy the download URL revocation timing.

Problems found (brief)

Drop only handles dataTransfer.files so folder drops won't work in Chrome/Edge (they need webkitGetAsEntry traversal).

fileInput is missing webkitdirectory if you want folder selection.

minifyHTML / minifyJS / minifyCSS are very naive and may corrupt content inside <pre>, <code> or <textarea> and some JS strings.

downloadString() calls URL.revokeObjectURL(url) immediately; revoke should be delayed after click() so the download completes.

Serialising HTML via XMLSerializer().serializeToString(doc) can drop DOCTYPE or change namespaces; better to preserve DOCTYPE.

When extracting inline resources, name collisions may occur across files with the same base name — consider uniqueName().



---

Drop-in patch

Replace the following parts in your file:

1. Replace the <input id="fileInput" ... /> element (make it allow folder selection in Chrome/Edge). Find the element and replace with this:



<!-- Replace your fileInput element with this to support folder selection (Chrome/Edge) -->
<input id="fileInput" type="file" webkitdirectory directory multiple style="display:none" />

2. Replace the current drag/drop handler (the simple drop event and dragover ones) with this more robust code that supports folder drops and files:



/* ===== Robust drag/drop and folder handling ===== */
function safeEntriesFromDataTransfer(dt) {
  const items = dt.items ? Array.from(dt.items) : [];
  if (items.length && typeof items[0].webkitGetAsEntry === 'function') {
    return { type: 'entries', entries: items.map(it => it.webkitGetAsEntry()).filter(Boolean) };
  }
  if (dt.files && dt.files.length) return { type: 'files', files: Array.from(dt.files) };
  // fallback: try getAsFile
  const files = [];
  for (const it of items) {
    try {
      const f = it.getAsFile && it.getAsFile();
      if (f) files.push(f);
    } catch (e) {}
  }
  return files.length ? { type: 'files', files } : { type: 'none' };
}

// Recursively read directory entries (webkit)
async function processEntries(entries, path = '') {
  for (const entry of entries) {
    if (!entry) continue;
    try {
      if (entry.isFile) {
        const file = await new Promise((resolve, reject) => entry.file(resolve, reject));
        const fullPath = path ? `${path}/${file.name}` : file.name;
        if (!filesToProcess.some(f => f.name === fullPath)) filesToProcess.push({ name: fullPath, file });
      } else if (entry.isDirectory) {
        const reader = entry.createReader();
        // collect batches
        let batch = await new Promise((res, rej) => reader.readEntries(res, rej));
        const all = [];
        while (batch && batch.length) {
          all.push(...batch);
          batch = await new Promise((res, rej) => reader.readEntries(res, rej));
        }
        const newPath = path ? `${path}/${entry.name}` : entry.name;
        await processEntries(all, newPath);
      }
    } catch (err) {
      log(`Error reading entry ${entry && entry.name ? entry.name : '(unknown)'}: ${err && err.message ? err.message : err}`);
    }
  }
  renderFileList();
}

// Robust drop handlers
dropzone.addEventListener('dragover', (e) => {
  e.preventDefault();
  dropzone.classList.add('active');
  e.dataTransfer.dropEffect = 'copy';
});
dropzone.addEventListener('dragleave', (e) => {
  e.preventDefault();
  const rect = dropzone.getBoundingClientRect();
  if (e.clientX < rect.left || e.clientX > rect.right || e.clientY < rect.top || e.clientY > rect.bottom) {
    dropzone.classList.remove('active');
  }
});
dropzone.addEventListener('drop', async (e) => {
  e.preventDefault();
  dropzone.classList.remove('active');
  const info = safeEntriesFromDataTransfer(e.dataTransfer);
  if (info.type === 'entries') {
    await processEntries(info.entries);
  } else if (info.type === 'files') {
    handleFileList(info.files);
  } else {
    showStatus('Dropped data did not contain files or folders', 'error');
    log('Drop did not contain files or folder entries');
  }
});

3. Replace downloadString() with safer revoke timing — find your function and replace with:



function downloadString(content, filename, mime = 'application/octet-stream') {
  // Accept either Blob or string
  if (content instanceof Blob) {
    const url = URL.createObjectURL(content);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    // revoke after a short delay so the download can start
    setTimeout(() => URL.revokeObjectURL(url), 2000);
    return;
  }
  const blob = new Blob([content], { type: mime });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(url), 2000);
}

4. Use a safer HTML minify that protects pre/code/textarea (replace your existing minifyHTML with this):



function minifyHTML(content) {
  // protect blocks that should keep whitespace
  const protectTags = ['pre','code','textarea'];
  const tokens = [];
  let i = 0;
  protectTags.forEach(tag => {
    const re = new RegExp(`<${tag}([\\s\\S]*?)>([\\s\\S]*?)<\\/${tag}>`, 'gi');
    content = content.replace(re, (m) => {
      const token = `__PROTECT_${i}__`;
      tokens.push({ token, m });
      i++;
      return token;
    });
  });
  // safe collapse
  content = content.replace(/\s+/g, ' ').replace(/>\s+</g, '><').trim();
  // restore tokens
  tokens.forEach(t => content = content.replace(t.token, t.m));
  return content;
}

5. Preserve DOCTYPE when serialising — replace your serialise call XMLSerializer().serializeToString(doc) with:



function serializeDoc(doc) {
  let doctype = '';
  const dt = doc.doctype;
  if (dt) {
    doctype = '<!DOCTYPE ' + dt.name;
    if (dt.publicId) doctype += ' PUBLIC "' + dt.publicId + '"';
    if (dt.systemId) doctype += ' "' + dt.systemId + '"';
    doctype += '>\n';
  }
  const html = doc.documentElement ? doc.documentElement.outerHTML : new XMLSerializer().serializeToString(doc);
  return doctype + html;
}

6. (Optional but recommended) Add uniqueName helper if you extract inline resources, to avoid collisions:



function uniqueName(base, ext, processedObj) {
  let name = base + ext, idx = 1;
  while (processedObj[name]) {
    name = `${base}(${idx})${ext}`;
    idx++;
  }
  return name;
}

When creating extracted files use uniqueName(base, '.css', processed) and uniqueName(base, '.js', processed).


---

How to apply

Paste (1) into your HTML where the file input currently is.

Replace the old drag/drop code and processEntries with (2).

Replace downloadString() with (3).

Swap minifyHTML() with (4).

Replace any serializeToString usage with serializeDoc() from (5).

Optionally add uniqueName() and use it when assigning names for extracted files.



---

Quick sanity checklist after patch

Try dragging a folder from your desktop (Chrome/Edge) — you should see nested files added with their relative paths.

Try dragging single files (any browser) — they should be added.

Process an HTML with <pre> containing lots of whitespace — minification should not break the whitespace inside <pre>.

Download a processed file and check it opens (the delayed revoke prevents premature URL invalidation).



---

If you’d prefer, I can paste a complete updated single-file HTML with all these exact changes applied so you can save it and test immediately. Want me to do that?

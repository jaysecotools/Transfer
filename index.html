// REPLACE the generateVRHTML method with this dual-compatible version:
generateVRHTML(projectData) {
    const markers = projectData.markers.map(marker => {
        const phi = marker.phi || this.convertXToPhi(marker.x);
        const theta = marker.theta || this.convertYToTheta(marker.y);
        
        return {
            ...marker,
            phi: phi,
            theta: theta,
            position: this.sphericalToCartesian(phi, theta, 5)
        };
    });

    const markersHTML = markers.map(marker => {
        const escapedData = JSON.stringify(marker)
            .replace(/'/g, "&apos;")
            .replace(/"/g, "&quot;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;");

        const markerStyle = this.getVRMarkerStyle(marker);
        
        return `
        <a-entity class="interactive-marker" 
            data-marker='${escapedData}'
            position="${marker.position}"
            animation="property: rotation; to: 0 360 0; loop: true; dur: 10000">
            
            <!-- Clickable area for both mouse and VR -->
            <a-sphere 
                class="clickable-target"
                radius="0.4"
                color="#0000FF" 
                opacity="0.01"
                material="transparent: true; opacity: 0.01"
                event-set__mouseenter="scale: 1.1 1.1 1.1"
                event-set__mouseleave="scale: 1 1 1">
            </a-sphere>
            
            ${markerStyle.outerRing}
            ${markerStyle.innerCore}
            ${markerStyle.icon}
            
            <a-text 
                value="${this.escapeHtml(marker.title)}" 
                position="0 0.8 0" 
                align="center" 
                color="white"
                scale="1.5 1.5 1.5"
                width="3">
            </a-text>
            
            <a-text 
                value="${markerStyle.typeLabel}" 
                position="0 -0.5 0" 
                align="center" 
                color="${markerStyle.textColor}"
                scale="1 1 1"
                width="2">
            </a-text>
        </a-entity>`;
    }).join('');

    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>360Â° VR Experience</title>
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/aframe-event-set-component@4.2.1/dist/aframe-event-set-component.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        .info-panel {
            position: fixed; top: 20px; left: 20px; background: rgba(0,0,0,0.95); 
            color: white; padding: 20px; border-radius: 10px; max-width: 400px; 
            max-height: 80vh; overflow-y: auto; z-index: 1000; display: none;
            border: 2px solid #6366f1; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .close-btn {
            position: absolute; top: 10px; right: 15px; background: none; border: none;
            color: white; font-size: 20px; cursor: pointer; padding: 0; width: 30px; height: 30px;
            display: flex; align-items: center; justify-content: center;
        }
        .close-btn:hover { background: rgba(255,255,255,0.1); border-radius: 50%; }
        .media-container { margin-top: 15px; }
        
        /* VR controller styles */
        .vr-controller {
            display: none;
        }
        
        /* Make click targets visible during development */
        /* .clickable-target { opacity: 0.3 !important; } */
    </style>
</head>
<body>
    <a-scene 
        vr-mode-ui="enabled: true" 
        loading-screen="dotsColor: #6366f1; backgroundColor: #000"
        cursor="rayOrigin: mouse"
        raycaster="objects: .clickable-target; far: 20">
        
        <a-sky src="${projectData.imageSrc}"></a-sky>
        
        ${markersHTML}
        
        <!-- Camera with cursor for PC -->
        <a-entity id="camera" position="0 0 0">
            <a-camera look-controls wasd-controls>
                <a-cursor
                    id="mouse-cursor"
                    fuse="true"
                    fuse-timeout="1500"
                    animation__click="property: scale; startEvents: click; from: 0.1 0.1 0.1; to: 1 1 1; dur: 150"
                    animation__fusing="property: scale; startEvents: fusing; from: 1 1 1; to: 0.1 0.1 0.1; dur: 1500"
                    raycaster="objects: .clickable-target">
                </a-cursor>
            </a-camera>
        </a-entity>
        
        <!-- VR Controllers -->
        <a-entity class="vr-controller" laser-controls="hand: right" raycaster="objects: .clickable-target; far: 20"></a-entity>
        <a-entity class="vr-controller" laser-controls="hand: left" raycaster="objects: .clickable-target; far: 20"></a-entity>
        
        <a-entity light="type: ambient; color: #888; intensity: 0.8"></a-entity>
        <a-entity light="type: directional; color: #fff; intensity: 0.5" position="-1 1 1"></a-entity>
    </a-scene>

    <div class="info-panel" id="infoPanel">
        <button class="close-btn" onclick="closeInfoPanel()">&times;</button>
        <h3 id="panelTitle" style="margin-bottom: 15px; color: #6366f1;">Marker Info</h3>
        <p id="panelDescription" style="margin-bottom: 15px; line-height: 1.5;"></p>
        <a id="panelLink" target="_blank" rel="noopener" style="display: none; padding: 8px 16px; background: #10b981; color: white; text-decoration: none; border-radius: 4px; margin-right: 10px;">ðŸ”— Visit Link</a>
        <div class="media-container" id="panelMedia"></div>
    </div>

    <script>
        // Wait for A-Frame to load
        document.addEventListener('DOMContentLoaded', function() {
            const scene = document.querySelector('a-scene');
            
            if (scene.hasLoaded) {
                initializeInteractions();
            } else {
                scene.addEventListener('loaded', initializeInteractions);
            }
        });

        function initializeInteractions() {
            setupMouseInteractions();
            setupVRInteractions();
            setupCursorEvents();
        }

        function setupMouseInteractions() {
            // Handle direct mouse clicks on markers
            const markers = document.querySelectorAll('.interactive-marker');
            
            markers.forEach(marker => {
                marker.addEventListener('click', function(evt) {
                    handleMarkerInteraction(this);
                });
            });
        }

        function setupVRInteractions() {
            // Handle VR controller events
            const scene = document.querySelector('a-scene');
            
            // Controller trigger events
            scene.addEventListener('triggerdown', function(evt) {
                const controller = evt.detail.target;
                const intersected = controller.components.raycaster.intersectedEl;
                
                if (intersected && intersected.classList.contains('clickable-target')) {
                    const marker = findParentMarker(intersected);
                    if (marker) {
                        handleMarkerInteraction(marker);
                    }
                }
            });
        }

        function setupCursorEvents() {
            const cursor = document.querySelector('#mouse-cursor');
            
            if (cursor) {
                // Handle cursor fuse completion (gaze interaction)
                cursor.addEventListener('fusing', function(evt) {
                    const intersectedEl = evt.detail.intersectedEl;
                    if (intersectedEl && intersectedEl.classList.contains('clickable-target')) {
                        const marker = findParentMarker(intersectedEl);
                        if (marker) {
                            handleMarkerInteraction(marker);
                        }
                    }
                });
            }
        }

        function findParentMarker(element) {
            let current = element;
            while (current && !current.classList.contains('interactive-marker')) {
                current = current.parentElement;
                if (!current) return null;
            }
            return current;
        }

        function handleMarkerInteraction(markerEntity) {
            const markerData = markerEntity.getAttribute('data-marker');
            if (markerData) {
                try {
                    const marker = JSON.parse(markerData);
                    showMarkerInfo(marker);
                    
                    // Visual feedback
                    markerEntity.setAttribute('animation', {
                        property: 'scale',
                        to: '1.2 1.2 1.2',
                        dur: 200,
                        dir: 'alternate'
                    });
                    
                    setTimeout(() => {
                        markerEntity.setAttribute('scale', '1 1 1');
                    }, 200);
                    
                } catch (error) {
                    console.error('Error parsing marker data:', error);
                }
            }
        }

        function showMarkerInfo(marker) {
            document.getElementById('panelTitle').textContent = marker.title || 'Untitled Marker';
            document.getElementById('panelDescription').textContent = marker.description || 'No description provided.';
            
            const linkElement = document.getElementById('panelLink');
            if (marker.url && marker.url.trim() !== '') {
                linkElement.href = marker.url;
                linkElement.textContent = 'ðŸ”— Visit Link';
                linkElement.style.display = 'inline-block';
            } else {
                linkElement.style.display = 'none';
            }
            
            const mediaElement = document.getElementById('panelMedia');
            mediaElement.innerHTML = '';
            
            if (marker.mediaUrl && marker.mediaUrl.trim() !== '') {
                mediaElement.innerHTML = getMediaEmbed(marker.mediaUrl);
            }
            
            document.getElementById('infoPanel').style.display = 'block';
        }

        function closeInfoPanel() {
            document.getElementById('infoPanel').style.display = 'none';
        }

        function getMediaEmbed(url) {
            if (!url) return '';
            
            if (url.includes('youtube.com') || url.includes('youtu.be')) {
                const videoId = extractYouTubeId(url);
                if (videoId) {
                    return '<div style="margin-top: 10px;"><iframe width="100%" height="200" src="https://www.youtube.com/embed/' + videoId + '?rel=0&modestbranding=1" frameborder="0" allowfullscreen style="border-radius: 8px;"></iframe></div>';
                }
            }
            
            if (url.includes('vimeo.com')) {
                const videoId = extractVimeoId(url);
                if (videoId) {
                    return '<div style="margin-top: 10px;"><iframe width="100%" height="200" src="https://player.vimeo.com/video/' + videoId + '?title=0&byline=0&portrait=0" frameborder="0" allowfullscreen style="border-radius: 8px;"></iframe></div>';
                }
            }
            
            if (url.match(/\\.(mp3|wav|ogg|m4a)(\\?.*)?$/i)) {
                return '<audio controls style="width: 100%; margin-top: 10px; border-radius: 8px;"><source src="' + url + '">Your browser does not support audio.</audio>';
            }
            
            if (url.match(/\\.(mp4|webm|ogg|mov)(\\?.*)?$/i)) {
                return '<video controls style="width: 100%; max-width: 100%; margin-top: 10px; border-radius: 8px;"><source src="' + url + '">Your browser does not support video.</video>';
            }
            
            return '<a href="' + url + '" target="_blank" rel="noopener" style="display: inline-block; padding: 10px 20px; background: #6366f1; color: white; text-decoration: none; border-radius: 6px; margin-top: 10px; font-weight: bold;">Open Media</a>';
        }

        function extractYouTubeId(url) {
            const patterns = [
                /(?:https?:\\/\\/)?(?:www\\.)?(?:youtube\\.com\\/watch\\?v=|youtu\\.be\\/)([^&\\n?#]+)/,
                /(?:https?:\\/\\/)?(?:www\\.)?youtube\\.com\\/embed\\/([^&\\n?#]+)/
            ];
            for (const pattern of patterns) {
                const match = url.match(pattern);
                if (match && match[1]) return match[1].split('?')[0].split('&')[0];
            }
            return null;
        }

        function extractVimeoId(url) {
            const match = url.match(/(?:https?:\\/\\/)?(?:www\\.)?vimeo\\.com\\/([0-9]+)/);
            return match ? match[1] : null;
        }

        document.addEventListener('click', function(e) {
            const panel = document.getElementById('infoPanel');
            if (panel && panel.style.display === 'block' && !panel.contains(e.target)) {
                closeInfoPanel();
            }
        });

        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeInfoPanel();
            }
        });
    </script>
</body>
</html>`;
}
